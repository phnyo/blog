---
title: "The Road to Monads: Applicativeについて"
date: 2021-12-05T11:22:10+09:00
tags:
- Haskell
- 翻訳
---

[Functorについての覚え書き](/post/functor/)の続き。

### Applicative Functor

FunctorはWrapperで、fmapを使えば(a -> b)->(f a -> f b)という風にFunctorの要素に対して関数を適用できたのだった。

でもこれだと問題があって、例えば
```
f :: Int -> Int -> Int
f a b = a * b
```
みたいな関数をMaybe Intで置き換えて使おうと思ったときに使えない。
というか単純に一変数関数にしか使えん。
これはけっこうだるい。

そこで、その代替策がApplicativeなのだがこれもこれとして理解し難い。
まずは関数定義から見てみよう。
```
class functor f => Applicative f where
  pure :: a -> f a
  (<*>) :: f (a -> b) -> f a -> f b
```
ここで()に囲まれているのは演算子であることを思い出そう。
すると、まずpureはある型 a からFunctor a型に移すようなものだとわかる。
pureはfunctorのデフォルトであるべき（らしい）なので、簡単な例だとMaybeに対して
```
pure a -> Just a
```
である。どこがpureなのかはいまいちよくわからない。

Haskellでは関数も型なので、こういうこともできる。ある項+1を取れば、
```
pure (+1) -> Just (+1)
```
このJust(+1)の型はMaybe(a -> a)である。

うん。まあなんとなくはわかった感がある。

次は(<\*>)について。
なにこいつ、なまこっぽいみたいな感想が先に立つけどまあうん。
実はよく見るとfmapに似ていることがわかる。
```
fmap :: (a -> b) -> f a -> f b
<*> :: f (a -> b) -> f a -> f b
```
ここでの違いは、もう関数がFunctorに埋め込まれているかどうかだけ。

だから実は
```
pure a -> f a
```
を思い出せば、型システムから
```
fmap f x = pure f <*> x
```
であることがわかる。

具体例を作ってみよう。
```
fn :: a -> b
```
に対して
```
pure fn :: f (a -> b) 
```
なので、
```
pure fn <*> :: a -> f b
fmap fn :: a -> f b
```
がいえる。ふう。もちろん、ここでfはFunctorの型でaは関数の引数である。

いや、なんの役に立つねん。
うーんと、実はなまこ<\*>の重要性は関数を取ることにある。

<\*>の引数はf(a -> b)といってるけど、このbがc -> d -> e型だった場合について考えよう。
一回<\*>を適用すると、返り値はf b だけどこれは実際には f( c -> d -> e )の型。
あれ？これってさっきと同じ形じゃない？
そう、そのとおりで、cをa、d -> eをbと置き換えると、<\*>をもう一回適用することでf(d -> e)がでて、結局f eの値が出ることになる。
その過程で、入力にf a、f b、f c、f dの値が必要になる。
これって引数が多い関数じゃない？そう。
だから再帰的なアプローチを関数に対して取ることで（！？）うまく引数の多い関数を実装できるような仕組みができているのだった。

具体的な例を見よう。
```





