<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>鯖の味噌煮がおいしく炊けない</title>
    <link>https://miso.sabanium.me/</link>
    <description>Recent content on 鯖の味噌煮がおいしく炊けない</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-JP</language>
    <lastBuildDate>Thu, 23 Dec 2021 16:42:30 +0900</lastBuildDate><atom:link href="https://miso.sabanium.me/index.xml" rel="self" type="application/rss+xml" />
    <item>
    <title>Rust覚え書き</title>
    <link>https://miso.sabanium.me/post/rust/</link>
    <pubDate>Thu, 23 Dec 2021 16:42:30 +0900</pubDate>
    
    <guid>https://miso.sabanium.me/post/rust/</guid>
    <description>
        &lt;h3 id=&#34;入出力&#34;&gt;
    &lt;a href=&#34;#%e5%85%a5%e5%87%ba%e5%8a%9b&#34; class=&#34;anchor&#34;&gt;
        &lt;svg class=&#34;icon&#34; aria-hidden=&#34;true&#34; focusable=&#34;false&#34; height=&#34;16&#34; version=&#34;1.1&#34; viewBox=&#34;0 0 16 16&#34; width=&#34;16&#34;&gt;
            &lt;path fill-rule=&#34;evenodd&#34;
                d=&#34;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&#34;&gt;
            &lt;/path&gt;
        &lt;/svg&gt;
    &lt;/a&gt;
    入出力
&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;String&lt;/code&gt;型の&lt;code&gt;buf&lt;/code&gt;への入力&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;use std::io::Read;

fn main() {
    let mut buf = String::new();
    std::io::stdin().read_to_string(&amp;amp;mut buf).unwrap();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;i64&lt;/code&gt;型の配列への入力&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;let mut iter = buf.split(&amp;quot;\n&amp;quot;);
let v1:Vec&amp;lt;i64&amp;gt; = iter.next().unwrap().split_whitespace().map(|x| x.parse::&amp;lt;i64&amp;gt;().unwrap()).collect();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;もしくは可読性を上げて&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;let mut iter = buf.split(&amp;quot;\n&amp;quot;);
let v1:Vec&amp;lt;i64&amp;gt; = iter.next().unwrap().split_whitespace().map(|x| {
                    x.parse::&amp;lt;i64&amp;gt;().unwrap()
                  }).collect();
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;配列&#34;&gt;
    &lt;a href=&#34;#%e9%85%8d%e5%88%97&#34; class=&#34;anchor&#34;&gt;
        &lt;svg class=&#34;icon&#34; aria-hidden=&#34;true&#34; focusable=&#34;false&#34; height=&#34;16&#34; version=&#34;1.1&#34; viewBox=&#34;0 0 16 16&#34; width=&#34;16&#34;&gt;
            &lt;path fill-rule=&#34;evenodd&#34;
                d=&#34;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&#34;&gt;
            &lt;/path&gt;
        &lt;/svg&gt;
    &lt;/a&gt;
    配列
&lt;/h3&gt;
&lt;p&gt;VectorでもArrayでもいい。&lt;code&gt;Collect()&lt;/code&gt;すると&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;になる。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Array&lt;/code&gt;の初期化&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;分かっている状態での初期化
let arr: [T; num of elements] = [直書き]
繰り返したいとき
let arr: [T; num of elements] = [elem; num of elements]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;debug&#34;&gt;
    &lt;a href=&#34;#debug&#34; class=&#34;anchor&#34;&gt;
        &lt;svg class=&#34;icon&#34; aria-hidden=&#34;true&#34; focusable=&#34;false&#34; height=&#34;16&#34; version=&#34;1.1&#34; viewBox=&#34;0 0 16 16&#34; width=&#34;16&#34;&gt;
            &lt;path fill-rule=&#34;evenodd&#34;
                d=&#34;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&#34;&gt;
            &lt;/path&gt;
        &lt;/svg&gt;
    &lt;/a&gt;
    debug
&lt;/h3&gt;
&lt;p&gt;type check&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;use std::any::type_name;

fn type_of&amp;lt;T&amp;gt;(_: T) -&amp;gt; &amp;amp;&#39;static str {
    type_name::&amp;lt;T&amp;gt;()
}
&lt;/code&gt;&lt;/pre&gt;
    </description>
    </item>
    
    <item>
    <title>i3wmをubuntuで導入し、いい感じにする</title>
    <link>https://miso.sabanium.me/post/i3/</link>
    <pubDate>Tue, 21 Dec 2021 00:16:14 +0900</pubDate>
    <author>sabanium</author>
    <guid>https://miso.sabanium.me/post/i3/</guid>
    <description>
        &lt;p&gt;これは&lt;a href=&#34;https://adventar.org/6389&#34;&gt;RICORA言語班 Advent Calendar&lt;/a&gt;の18日目の記事です。新入生相手におままごとをしていたら完全に書くのを忘れていたので、適当なことを書きます。すみません。&lt;/p&gt;
&lt;h3 id=&#34;背景&#34;&gt;
    &lt;a href=&#34;#%e8%83%8c%e6%99%af&#34; class=&#34;anchor&#34;&gt;
        &lt;svg class=&#34;icon&#34; aria-hidden=&#34;true&#34; focusable=&#34;false&#34; height=&#34;16&#34; version=&#34;1.1&#34; viewBox=&#34;0 0 16 16&#34; width=&#34;16&#34;&gt;
            &lt;path fill-rule=&#34;evenodd&#34;
                d=&#34;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&#34;&gt;
            &lt;/path&gt;
        &lt;/svg&gt;
    &lt;/a&gt;
    背景
&lt;/h3&gt;
&lt;p&gt;windows10をサクサク動かせないPCを普段使いするためにはどうすればいいのだろうか？という問題が与えられたとき、大体ubuntuとかlinux mintみたいな軽量ディストロがおすすめされると思うのですが、あえてウィンドウマネージャーの方から攻めてみたいと思ったので書きます。&lt;/p&gt;
&lt;h3 id=&#34;導入とか&#34;&gt;
    &lt;a href=&#34;#%e5%b0%8e%e5%85%a5%e3%81%a8%e3%81%8b&#34; class=&#34;anchor&#34;&gt;
        &lt;svg class=&#34;icon&#34; aria-hidden=&#34;true&#34; focusable=&#34;false&#34; height=&#34;16&#34; version=&#34;1.1&#34; viewBox=&#34;0 0 16 16&#34; width=&#34;16&#34;&gt;
            &lt;path fill-rule=&#34;evenodd&#34;
                d=&#34;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&#34;&gt;
            &lt;/path&gt;
        &lt;/svg&gt;
    &lt;/a&gt;
    導入とか
&lt;/h3&gt;
&lt;p&gt;dotfileとかどうせ上げてるんだろ？ → はい。&lt;a href=&#34;https://github.com/phnyo/dotfiles&#34;&gt;これ&lt;/a&gt;です。見たければ見てもいいよ。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://i3wm.org&#34;&gt;i3&lt;/a&gt;はフリーソースのタイル型ウィンドウマネージャです。
タイル型ウィンドウマネージャは、画面上のアプリケーションを画面を埋めるように配置します。&lt;/p&gt;
&lt;p&gt;個人的に感じるi3のメリットは、カーソルを動かす必要がない（＝キーボード上で操作が完結する）ことと、バッテリーの持ちが非常に良くなることです。
もちろん&lt;code&gt;acpi&lt;/code&gt;で充電の上限は設けていますが、大体70%充電しておけば６時間程度は使えるはずです。
さらに、&lt;code&gt;feh&lt;/code&gt;などを用いることで背景を設定することもでき、&lt;code&gt;i3bar&lt;/code&gt;や&lt;code&gt;i3status&lt;/code&gt;を調整することで、天気やバッテリー情報などを常時表示することもできます。&lt;/p&gt;
&lt;h4 id=&#34;導入方法&#34;&gt;
    &lt;a href=&#34;#%e5%b0%8e%e5%85%a5%e6%96%b9%e6%b3%95&#34; class=&#34;anchor&#34;&gt;
        &lt;svg class=&#34;icon&#34; aria-hidden=&#34;true&#34; focusable=&#34;false&#34; height=&#34;16&#34; version=&#34;1.1&#34; viewBox=&#34;0 0 16 16&#34; width=&#34;16&#34;&gt;
            &lt;path fill-rule=&#34;evenodd&#34;
                d=&#34;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&#34;&gt;
            &lt;/path&gt;
        &lt;/svg&gt;
    &lt;/a&gt;
    導入方法
&lt;/h4&gt;
&lt;p&gt;i3は文献があまりになさすぎるので、いつもの&lt;a href=&#34;https://wiki.archlinux.jp/index.php/I3&#34;&gt;arch wiki&lt;/a&gt;に全面的に頼ることになります。
私も全面的に頼りました。&lt;/p&gt;
&lt;p&gt;archで入れているわけではないので、ubuntuを使いつつ入れる方法を説明します。&lt;/p&gt;
&lt;p&gt;公式でおすすめされているのは、配布されているtarballを用いる方法ですが、&lt;code&gt;apt&lt;/code&gt;でも拾ってこれます。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo apt install i3 i3-wm
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;このくらいで十分だった気がする。
足りなくなったら都度足してください。&lt;/p&gt;
&lt;p&gt;i3をインストールすると、ログイン画面の右下に歯車マークが出て、ログイン後のウィンドウマネージャが選べるようになります。
これでi3を選択してログインすれば、無事にインストール完了です。&lt;/p&gt;
&lt;h3 id=&#34;操作&#34;&gt;
    &lt;a href=&#34;#%e6%93%8d%e4%bd%9c&#34; class=&#34;anchor&#34;&gt;
        &lt;svg class=&#34;icon&#34; aria-hidden=&#34;true&#34; focusable=&#34;false&#34; height=&#34;16&#34; version=&#34;1.1&#34; viewBox=&#34;0 0 16 16&#34; width=&#34;16&#34;&gt;
            &lt;path fill-rule=&#34;evenodd&#34;
                d=&#34;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&#34;&gt;
            &lt;/path&gt;
        &lt;/svg&gt;
    &lt;/a&gt;
    操作
&lt;/h3&gt;
&lt;p&gt;i3はまあまあ独特な動きをします（vimよりは習得コストが低いかもしれない）。
キーマップの完全版は&lt;a href=&#34;https://i3wm.org/docs/userguide.html#_default_keybindings&#34;&gt;Default Keybindings&lt;/a&gt;を参照してください。&lt;/p&gt;
&lt;p&gt;i3を使う際には&lt;code&gt;mod&lt;/code&gt;と呼ばれる特殊キーを設定する必要があります。
私はaltキーに設定して使っていますが、この&lt;code&gt;mod&lt;/code&gt;キーと何らかのキーを同時に押すことで画面の操作を行います。&lt;/p&gt;
&lt;p&gt;例えば、&lt;code&gt;mod + 1&lt;/code&gt;なら1番目のウィンドウに移動します。
また、&lt;code&gt;mod + shift + 1&lt;/code&gt;なら現在のウィンドウを1番目のウィンドウに移動させます。
意味がわかりませんね。手を動かさないと理解できないので自分で頑張ってi3を使ってみてください。&lt;/p&gt;
&lt;h3 id=&#34;i3&#34;&gt;
    &lt;a href=&#34;#i3&#34; class=&#34;anchor&#34;&gt;
        &lt;svg class=&#34;icon&#34; aria-hidden=&#34;true&#34; focusable=&#34;false&#34; height=&#34;16&#34; version=&#34;1.1&#34; viewBox=&#34;0 0 16 16&#34; width=&#34;16&#34;&gt;
            &lt;path fill-rule=&#34;evenodd&#34;
                d=&#34;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&#34;&gt;
            &lt;/path&gt;
        &lt;/svg&gt;
    &lt;/a&gt;
    i3
&lt;/h3&gt;
&lt;p&gt;i3の設定ファイルは、ルート直下の&lt;code&gt;.config/i3/config&lt;/code&gt;になります。
デフォルトでは生成されていなかったと思うので、そのようなファイルを新しく作って設定してあげると勝手にファイルを見に行ってくれます。
確か開発レポジトリをクローンしてきてブランチをcheckoutするとデフォの設定が入っているconfigがあるはずです。
おそらく初見で利用する際にはそれをコピー・コピーアンドペーストするといいと思います。&lt;/p&gt;
&lt;p&gt;私が追記している設定は確かこんな感じです。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;画面閉じたらスリープさせる(だった気がする)
exec --no-startup-id xss-lock --transfer-sleep-lock -- i3lock --nofork

日本語入力用のibusを裏で起動
exec --no-startup-id ibus-daemon -x -d -r

背景の起動
exec --no-startup-id ~/.fehbg

明るさ
exec --no-startup-id compton -cbm 0.6

通知マネージャのDunstをきちんと動かしたかった...
exec --no-startup-id dunst -print -config &amp;quot;/home/n/.config/dunst/dunstrc&amp;quot;

音量の上げ下げ
bindsym XF86AudioRaiseVolume exec --no-startup-id pactl set-sink-volume @DEFAULT_SINK@ +10% &amp;amp;&amp;amp; $refresh_i3status
bindsym XF86AudioLowerVolume exec --no-startup-id pactl set-sink-volume @DEFAULT_SINK@ -10% &amp;amp;&amp;amp; $refresh_i3status

ミュート
bindsym XF86AudioMute exec --no-startup-id pactl set-sink-mute @DEFAULT_SINK@ toggle &amp;amp;&amp;amp; $refresh_i3status
bindsym XF86AudioMicMute exec --no-startup-id pactl set-source-mute @DEFAULT_SOURCE@ toggle &amp;amp;&amp;amp; $refresh_i3status

音量調整
bindsym XF86MonBrightnessUp exec --no-startup-id brightnessctl set +10%
bindsym XF86MonBrightnessDown exec --no-startup-id brightnessctl set 10%-
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;音量調整はだるいというかリファレンスがなくてstack overflowとかに頼りまくりですが多分これで動くはず。&lt;/p&gt;
&lt;h3 id=&#34;i3bar&#34;&gt;
    &lt;a href=&#34;#i3bar&#34; class=&#34;anchor&#34;&gt;
        &lt;svg class=&#34;icon&#34; aria-hidden=&#34;true&#34; focusable=&#34;false&#34; height=&#34;16&#34; version=&#34;1.1&#34; viewBox=&#34;0 0 16 16&#34; width=&#34;16&#34;&gt;
            &lt;path fill-rule=&#34;evenodd&#34;
                d=&#34;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&#34;&gt;
            &lt;/path&gt;
        &lt;/svg&gt;
    &lt;/a&gt;
    i3bar
&lt;/h3&gt;
&lt;p&gt;大抵のOSは（勝手、あるいは不親切もしくは手を回しすぎているので）上か下に何らかの情報を表示するバーみたいなのがあります。
i3のバーはデフォルトではクソダサなのでどうにかこうにか整えていきましょう。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(username)/.config/i3/config&lt;/code&gt;の一番下にバーという項目があります。
&lt;a href=&#34;https://i3wm.org/docs/userguide.html#_configuring_i3bar&#34;&gt;いろんな設定ができる&lt;/a&gt;ので、適当に参照して動かしてください。
この設定の中で割と参照される設定は&lt;code&gt;font&lt;/code&gt;、&lt;code&gt;colors&lt;/code&gt;、&lt;code&gt;position&lt;/code&gt;とかだと思います。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;font&lt;/code&gt;はまあフォントなんですが、実は記号っぽい（例：バッテリーとか）を付け加えるフォントが存在し、それを利用するとメモリマークなどを表示させることができます。詳しくは&lt;code&gt;Awesome Font&lt;/code&gt;で調べてみてください。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;colors&lt;/code&gt;は色ですが、RGB16進表示で色変できます。よかったですね。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;position&lt;/code&gt;は確かtopとbottomしかないのですが、位置は変えられます。よかったですね２。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;いや肝心の表示するものは！？という話ですが、この設定は&lt;code&gt;(username)/.config/i3status/config&lt;/code&gt;で行います。
このファイルもデフォルトでは存在しないので、作ってくださいね。&lt;/p&gt;
&lt;p&gt;i3statusの設定によってバーに表示されるものの指定を行うことができます。
私のstatusにはこんな感じのものが表示されているらしいです。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;order += &amp;quot;read_file spotify&amp;quot;
order += &amp;quot;read_file weather&amp;quot;
order += &amp;quot;cpu_usage&amp;quot;
order += &amp;quot;memory&amp;quot;
order += &amp;quot;battery all&amp;quot;
order += &amp;quot;tztime local&amp;quot;
order += &amp;quot;wireless _first_&amp;quot;
order += &amp;quot;volume master&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;read_file&lt;/code&gt;以外はそれぞれの機器の現在の状況を読み取って表示してくれます。あとは&lt;a href=&#34;https://i3wm.org/docs/i3status.html&#34;&gt;詳細&lt;/a&gt;を読んでね。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;read_file&lt;/code&gt;はファイルを読んで表示してくれる感じのやつです。
上のspotify、weatherはそれぞれspotifyと&lt;a href=&#34;wttr.in&#34;&gt;wttr.in&lt;/a&gt;から情報を拾ってきて表示するスクリプ卜のログを読んでいます。wttr.inはたまに止まってバグってわろてる。&lt;/p&gt;
&lt;p&gt;まあこんな感じでカスタマイズできます。&lt;/p&gt;
&lt;h3 id=&#34;スクリプトについて&#34;&gt;
    &lt;a href=&#34;#%e3%82%b9%e3%82%af%e3%83%aa%e3%83%97%e3%83%88%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6&#34; class=&#34;anchor&#34;&gt;
        &lt;svg class=&#34;icon&#34; aria-hidden=&#34;true&#34; focusable=&#34;false&#34; height=&#34;16&#34; version=&#34;1.1&#34; viewBox=&#34;0 0 16 16&#34; width=&#34;16&#34;&gt;
            &lt;path fill-rule=&#34;evenodd&#34;
                d=&#34;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&#34;&gt;
            &lt;/path&gt;
        &lt;/svg&gt;
    &lt;/a&gt;
    スクリプトについて
&lt;/h3&gt;
&lt;p&gt;スクリプトっていってもどういうスクリプトやねん。
はい。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#/usr/bin/bash

WEATHER_LOG=&amp;quot;/home/$(whoami)/.cache/weather/weather.log&amp;quot;

echo &amp;quot;Tsukuba &amp;quot; &amp;gt; $WEATHER_LOG
curl wttr.in/Tsukuba?format=1 | tr -d &#39;\n &#39; &amp;gt;&amp;gt; $WEATHER_LOG 
echo &amp;quot; / Unga &amp;quot; &amp;gt;&amp;gt; $WEATHER_LOG
curl wttr.in/Unga.Station?format=1 | tr -d &#39;\n &#39; &amp;gt;&amp;gt; $WEATHER_LOG
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;こんなん。大学が運河にあり、家がつくばにあるので&lt;code&gt;curl&lt;/code&gt;してそれを表示しています。
&lt;code&gt;cron&lt;/code&gt;で15分ごとに更新される手筈だが、wttr.inの天気の更新が遅いのでもはや参考情報にしかならないので観葉植物みたいなもん。spotifyのも同じ感じで、これもspofityを動かしてないといけないので観葉植物もどき。&lt;/p&gt;
&lt;p&gt;あとディスプレイの照度調整をするスクリプトを書かないと照度調整ができなかった（カス！）ので、それも書いた。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;CURRENT_VAL=$(cat /sys/class/backlight/intel_backlight/actual_brightness)
MAX_VAL=$(cat /sys/class/backlight/intel_backlight/max_brightness)

if [ $1 = &#39;-&#39; ]; then
  echo $(expr $CURRENT_VAL - $(expr $MAX_VAL / 20)) &amp;gt; /sys/class/backlight/intel_backlight/brightness
elif [ $1 = &#39;+&#39; ]; then
  echo $(expr $CURRENT_VAL + $(expr $MAX_VAL / 20)) &amp;gt; /sys/class/backlight/intel_backlight/brightness
fi
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;/sys/class/backlight/intel_backlight/brightness&lt;/code&gt;を読み書きすることで明るさ調整をしているらしいので、入力によってプラスしたりマイナスしたりした値を返すようにしています。なぜこれが組み込まれていないか謎。&lt;/p&gt;
&lt;h3 id=&#34;ファイル管理について&#34;&gt;
    &lt;a href=&#34;#%e3%83%95%e3%82%a1%e3%82%a4%e3%83%ab%e7%ae%a1%e7%90%86%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6&#34; class=&#34;anchor&#34;&gt;
        &lt;svg class=&#34;icon&#34; aria-hidden=&#34;true&#34; focusable=&#34;false&#34; height=&#34;16&#34; version=&#34;1.1&#34; viewBox=&#34;0 0 16 16&#34; width=&#34;16&#34;&gt;
            &lt;path fill-rule=&#34;evenodd&#34;
                d=&#34;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&#34;&gt;
            &lt;/path&gt;
        &lt;/svg&gt;
    &lt;/a&gt;
    ファイル管理について
&lt;/h3&gt;
&lt;p&gt;dotfileというレポを作って、&lt;code&gt;init.sh&lt;/code&gt;で初期設定を勝手にできるようにしています。というか.vimrcと.bashrcもあるので、それはrootにおいて、それ以外は.configを作成してそれに突っ込んでる。ubuntuでしか動かんが、ワシはそれでいいのでそれでいい。&lt;/p&gt;
&lt;h3 id=&#34;結論&#34;&gt;
    &lt;a href=&#34;#%e7%b5%90%e8%ab%96&#34; class=&#34;anchor&#34;&gt;
        &lt;svg class=&#34;icon&#34; aria-hidden=&#34;true&#34; focusable=&#34;false&#34; height=&#34;16&#34; version=&#34;1.1&#34; viewBox=&#34;0 0 16 16&#34; width=&#34;16&#34;&gt;
            &lt;path fill-rule=&#34;evenodd&#34;
                d=&#34;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&#34;&gt;
            &lt;/path&gt;
        &lt;/svg&gt;
    &lt;/a&gt;
    結論
&lt;/h3&gt;
&lt;p&gt;i3を使いたい気持ちになりましたか？早くwindowsかOS Xをディスクから完全に消し去り、i3と心中しましょう。おわり。&lt;/p&gt;

    </description>
    </item>
    
    <item>
    <title>The Road to Monads: Monadについて</title>
    <link>https://miso.sabanium.me/post/monad/</link>
    <pubDate>Mon, 06 Dec 2021 11:20:40 +0900</pubDate>
    <author>sabanium</author>
    <guid>https://miso.sabanium.me/post/monad/</guid>
    <description>
        &lt;p&gt;この記事は&lt;a href=&#34;https://oliverbalfour.github.io/haskell/2020/08/08/understanding-monads-haskell.html&#34;&gt;The Road to Monads&lt;/a&gt;を意訳したものであり、&lt;a href=&#34;https://adventar.org/calendars/6389&#34;&gt;RICORA Advent Calendar&lt;/a&gt;の11日目の記事です。&lt;/p&gt;
&lt;h2 id=&#34;monad&#34;&gt;
    &lt;a href=&#34;#monad&#34; class=&#34;anchor&#34;&gt;
        &lt;svg class=&#34;icon&#34; aria-hidden=&#34;true&#34; focusable=&#34;false&#34; height=&#34;16&#34; version=&#34;1.1&#34; viewBox=&#34;0 0 16 16&#34; width=&#34;16&#34;&gt;
            &lt;path fill-rule=&#34;evenodd&#34;
                d=&#34;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&#34;&gt;
            &lt;/path&gt;
        &lt;/svg&gt;
    &lt;/a&gt;
    Monad
&lt;/h2&gt;
&lt;p&gt;今までの流れを振り返ると、&lt;a href=&#34;https://miso.sabanium.me/post/functor&#34;&gt;Functor&lt;/a&gt;は何らかの値のWrapperであり、&lt;code&gt;fmap&lt;/code&gt;によってその要素に関数適用ができた。
&lt;a href=&#34;https://miso.sabanium.me/post/applicative&#34;&gt;Applicative Functor&lt;/a&gt;はそれをさらに発展させて、関数自体をFunctorで包むことによって、複数の引数を取る関数を実装できるようにしていたのだった。&lt;/p&gt;
&lt;p&gt;さて、何が足りないのだろう？
実は、Applicative Functorだけでは関数を複数組み合わせることが難しい。
例えば、&lt;code&gt;f :: a -&amp;gt; b&lt;/code&gt;と&lt;code&gt;g :: b -&amp;gt; c&lt;/code&gt;があったときに、Applicative Functorだと&lt;code&gt;a -&amp;gt; f b&lt;/code&gt;、&lt;code&gt;b -&amp;gt; f c&lt;/code&gt;に写すことはできても&lt;code&gt;a -&amp;gt; f c&lt;/code&gt;に写すことができない。
こういう関数の使い方をする機会は割と多い気がするし、こんな感じで書きたくない？という話。&lt;/p&gt;
&lt;p&gt;簡単にいえば、MonadはFunctorの中での関数合成を可能にする構造。
しかし、これだけだとMonadが実際に何をするかいまいちわからないので以下に書いていく。
導入として、大体FunctorみたいなものだとしてMonad&lt;code&gt;m&lt;/code&gt;を使うことにしよう(とはいっても、実装上は拡張したApplicative型なんだからFunctorの拡張として捉えるほうが適切かもしれない）。&lt;/p&gt;
&lt;p&gt;じつはMonadは他の必要っぽいことも包摂してくれている。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Monad上の関数の繰り返し適用に対して、Monadを圧縮する。&lt;code&gt;a -&amp;gt; m b&lt;/code&gt;に対してまたfmapをつかって&lt;code&gt;m&lt;/code&gt;を適用すると、&lt;code&gt;m a -&amp;gt; m (m -&amp;gt; b)&lt;/code&gt;になってしまう。
例えば、&lt;code&gt;a -&amp;gt; Maybe b&lt;/code&gt;なら&lt;code&gt;Maybe a -&amp;gt; Maybe ( Maybe b )&lt;/code&gt;的な。
これを圧縮して、繰り返し適用しても&lt;code&gt;a -&amp;gt; Maybe b&lt;/code&gt;の型を作れるようにする。&lt;/li&gt;
&lt;li&gt;さっきの例。
&lt;code&gt;a -&amp;gt; m b&lt;/code&gt;と&lt;code&gt;b -&amp;gt; m c&lt;/code&gt;から&lt;code&gt;a -&amp;gt; m c&lt;/code&gt;の関数を作りだせる。&lt;/li&gt;
&lt;li&gt;逆に&lt;code&gt;m a&lt;/code&gt;が与えられたとき、&lt;code&gt;a -&amp;gt; m b&lt;/code&gt;の関数を使えるようにする。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;型の圧縮&#34;&gt;
    &lt;a href=&#34;#%e5%9e%8b%e3%81%ae%e5%9c%a7%e7%b8%ae&#34; class=&#34;anchor&#34;&gt;
        &lt;svg class=&#34;icon&#34; aria-hidden=&#34;true&#34; focusable=&#34;false&#34; height=&#34;16&#34; version=&#34;1.1&#34; viewBox=&#34;0 0 16 16&#34; width=&#34;16&#34;&gt;
            &lt;path fill-rule=&#34;evenodd&#34;
                d=&#34;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&#34;&gt;
            &lt;/path&gt;
        &lt;/svg&gt;
    &lt;/a&gt;
    型の圧縮
&lt;/h3&gt;
&lt;p&gt;まあこれだけだとよくわからないので、具体例を考えよう。
&lt;code&gt;1 / sqrt (x)&lt;/code&gt;を&lt;code&gt;Maybe&lt;/code&gt;を返すとして考える。
この関数を二つの関数&lt;code&gt;1 / x&lt;/code&gt;と&lt;code&gt;sqrt(x)&lt;/code&gt;の合成で考えるとすると、例えば&lt;code&gt;1/0&lt;/code&gt;はundefinedなので、&lt;code&gt;1 / x&lt;/code&gt;で&lt;code&gt;x = 0&lt;/code&gt;なら&lt;code&gt;Nothing&lt;/code&gt;を返したい。
これは&lt;code&gt;sqrt(x)&lt;/code&gt;でも一緒。&lt;code&gt;x &amp;lt; 0&lt;/code&gt;なら&lt;code&gt;Nothing&lt;/code&gt;を返したい。
そこで、これらを実際に書いてみるとこんな感じ。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;safeInverse :: Double -&amp;gt; Maybe Double
safeInverse 0 = Nothing
safeInverse _ = Just(1/x)

safeSqrt :: Double -&amp;gt; Maybe Double
safeSqrt x = case signum x of
  (-1) -&amp;gt; Nothing
  _ -&amp;gt; Just (sqrt x)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ここで&lt;code&gt;signum&lt;/code&gt;は符号を返す関数。&lt;/p&gt;
&lt;p&gt;まあこれだけで完結するんだったらいいんだけど、もっとでかいプログラムの一部に組み込むなら&lt;code&gt;Maybe&lt;/code&gt;の場合分けをし続けることになる。
めんどくさい犬の散歩みたいだ。
&lt;code&gt;fmap&lt;/code&gt;をつかってもいいかもしれないけど、&lt;code&gt;fmap&lt;/code&gt;を使うと&lt;code&gt;1 / sqrt(x)&lt;/code&gt;の関数の型が&lt;code&gt;a -&amp;gt; Maybe (Maybe b)&lt;/code&gt;になってしまう。
これをもっとでかい関数の一部として使うとすると&amp;hellip;大変なことになりそうだ。&lt;/p&gt;
&lt;p&gt;それを避けるために、&lt;code&gt;join&lt;/code&gt;という関数を考える。
&lt;code&gt;Maybe&lt;/code&gt;に対してはこんな感じで書ける。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;join :: Maybe (Maybe a) -&amp;gt; Maybe a
join (Just x) = x
join Nothing = Nothing
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これは圧縮そのものだから、実際に&lt;code&gt;1 / sqrt(x)&lt;/code&gt;を書くと&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sqrtInverse :: Double -&amp;gt; Maybe Double
sqrtInverse = join ( fmap safeInverse (safeSqrt x))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;こんな感じ。
確認だけど、&lt;code&gt;fmap SafeInverse (safeSqrt x)&lt;/code&gt;が&lt;code&gt;Double -&amp;gt; Maybe (Maybe Double)&lt;/code&gt;型の関数なので、&lt;code&gt;join&lt;/code&gt;を使うと&lt;code&gt;Double -&amp;gt; Maybe Double&lt;/code&gt;になる。&lt;/p&gt;
&lt;p&gt;この&lt;code&gt;join&lt;/code&gt;は実際にこんな感じに一般化できるらしい。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;join :: Monad m =&amp;gt; m (m a) -&amp;gt; m a
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;関数の合成&#34;&gt;
    &lt;a href=&#34;#%e9%96%a2%e6%95%b0%e3%81%ae%e5%90%88%e6%88%90&#34; class=&#34;anchor&#34;&gt;
        &lt;svg class=&#34;icon&#34; aria-hidden=&#34;true&#34; focusable=&#34;false&#34; height=&#34;16&#34; version=&#34;1.1&#34; viewBox=&#34;0 0 16 16&#34; width=&#34;16&#34;&gt;
            &lt;path fill-rule=&#34;evenodd&#34;
                d=&#34;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&#34;&gt;
            &lt;/path&gt;
        &lt;/svg&gt;
    &lt;/a&gt;
    関数の合成
&lt;/h3&gt;
&lt;p&gt;この&lt;code&gt;sqrtInverse&lt;/code&gt;を関数の合成の観点から見てみよう。
さっきと同じように普通の値を取ってMonad内部の値を返すような関数を二つ考えて、それらを普通の値を取ってMonadの値として返す関数を想定するとき、&lt;code&gt;&amp;gt;=&amp;gt;&lt;/code&gt;という演算子を使うことができる。
例えば&lt;code&gt;f :: a -&amp;gt; m b&lt;/code&gt;と&lt;code&gt;g :: b -&amp;gt; m c&lt;/code&gt;があるとき、&lt;code&gt;f &amp;gt;=&amp;gt; g&lt;/code&gt;は&lt;code&gt;a -&amp;gt; m c&lt;/code&gt;という型になる。
この&lt;code&gt;&amp;gt;=&amp;gt;&lt;/code&gt;演算子は魚に似ている（？）のでfish演算子と呼ばれ、この合成自体はKleisli(クライスリ)合成というらしい。&lt;/p&gt;
&lt;p&gt;実際にこのfish演算子が使われている所を見てみよう。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;(&amp;gt;=&amp;gt;) :: (a -&amp;gt; Maybe b) -&amp;gt; (b -&amp;gt; Maybe c) -&amp;gt; (a -&amp;gt; Maybe c)
f &amp;gt;=&amp;gt; g = \x -&amp;gt; case f x of
  Just x -&amp;gt; g x
  Nothing -&amp;gt; Nothing
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;うん。
まず一行目はfish演算子を定義した通りの定義になっている。
そこで、二行目以降ではMonadがMaybeなので、&lt;code&gt;f x&lt;/code&gt;は&lt;code&gt;Just x&lt;/code&gt;か&lt;code&gt;Nothing&lt;/code&gt;を返し、&lt;code&gt;Just x&lt;/code&gt;ならunwrapして&lt;code&gt;g x&lt;/code&gt;を返すようにパターンマッチングしてあげている。&lt;/p&gt;
&lt;p&gt;このfish演算子を実際にさっきの&lt;code&gt;sqrtInverse&lt;/code&gt;に使おう。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sqrtInverse :: Double -&amp;gt; Maybe Double
sqrtInverse = safeSqrt &amp;gt;=&amp;gt; safeInverse
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;だいぶ短くなったし、これで明示的にパターンマッチングの処理をしなくてよくなったのでだいぶ見通しが良くなるはずだ。&lt;/p&gt;
&lt;p&gt;でもこれにはまだ問題がある。
Monadの中の値を使うときに恒等射的な関数を考える必要が出てくるのだ。
例えば&lt;code&gt;m a&lt;/code&gt;という値に対して&lt;code&gt;m a -&amp;gt; a&lt;/code&gt;という関数を作り、fish演算子を使う必要がある。
これだとまた型に合わせるための関数を作って見通しがまた良くなくなってしまう。&lt;/p&gt;
&lt;p&gt;実際にそういう例を見てみよう。
&lt;code&gt;const a b = a&lt;/code&gt;という関数を考えれば、&lt;code&gt;Just 5&lt;/code&gt;を計算するために&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;(const (Just 4) &amp;gt;=&amp;gt; (\x -&amp;gt; Just (x+1))) ()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;とする必要がある。&lt;/p&gt;
&lt;p&gt;ごちゃごちゃしててわかりにくいから型を確かめよう。
&lt;code&gt;\x -&amp;gt; Just(x + 1)&lt;/code&gt;は&lt;code&gt;Int -&amp;gt; Maybe Int&lt;/code&gt;という型で、&lt;code&gt;const Just 4&lt;/code&gt;は&lt;code&gt;Num a =&amp;gt; a -&amp;gt; Maybe b&lt;/code&gt;という型だ。
あれ、&lt;code&gt;const&lt;/code&gt;って引数2つ取るんじゃないの?と思うんだけど、それはカリー化されたものを見ているだけで、実際には1変数だけ取ることもできる（もちろん、&lt;code&gt;const a&lt;/code&gt;は&lt;code&gt;const a b&lt;/code&gt;とは違う関数）。&lt;/p&gt;
&lt;p&gt;それで&lt;code&gt;&amp;gt;=&amp;gt;&lt;/code&gt;が使えるが、型チェックをすると&lt;code&gt;(const Just 4 &amp;gt;=&amp;gt; (\x -&amp;gt; x + 1)) :: Num c =&amp;gt; b -&amp;gt; Maybe c&lt;/code&gt;なので、もう一つなにかの引数が必要っぽいことがわかるので、入れてあげると&lt;code&gt;Just 5&lt;/code&gt;が出る。
これはなんでもいい。
例えば&lt;code&gt;&#39;c&#39;&lt;/code&gt;でも&lt;code&gt;()&lt;/code&gt;でもいい。&lt;/p&gt;
&lt;h3 id=&#34;連続的に計算させる&#34;&gt;
    &lt;a href=&#34;#%e9%80%a3%e7%b6%9a%e7%9a%84%e3%81%ab%e8%a8%88%e7%ae%97%e3%81%95%e3%81%9b%e3%82%8b&#34; class=&#34;anchor&#34;&gt;
        &lt;svg class=&#34;icon&#34; aria-hidden=&#34;true&#34; focusable=&#34;false&#34; height=&#34;16&#34; version=&#34;1.1&#34; viewBox=&#34;0 0 16 16&#34; width=&#34;16&#34;&gt;
            &lt;path fill-rule=&#34;evenodd&#34;
                d=&#34;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&#34;&gt;
            &lt;/path&gt;
        &lt;/svg&gt;
    &lt;/a&gt;
    連続的に計算させる
&lt;/h3&gt;
&lt;p&gt;では、別の演算子&lt;code&gt;(&amp;gt;&amp;gt;=) :: m a -&amp;gt; (a -&amp;gt; m b) -&amp;gt; m b&lt;/code&gt;を考えよう。
これをbind(演算子?)と呼ぶ。&lt;/p&gt;
&lt;p&gt;Maybeに対して実装するとこんな感じ。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;(&amp;gt;&amp;gt;=) :: Maybe a -&amp;gt; (a -&amp;gt; Maybe b) -&amp;gt; Maybe b
x (&amp;gt;&amp;gt;=) f = case x of
  (Just x&#39;) -&amp;gt; f x&#39;
  Nothing -&amp;gt; Nothing
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ここで&lt;code&gt;x&lt;/code&gt;は&lt;code&gt;Maybe x&#39;&lt;/code&gt;という型だとした。&lt;/p&gt;
&lt;p&gt;さっきの&lt;code&gt;sqrtInverse&lt;/code&gt;をまた拾ってこよう。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sqrtInverse :: Double -&amp;gt; Maybe Double
sqrtInverse x = safeSqrt x &amp;gt;&amp;gt;= safeInverse
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;他の例としてこういうのもある。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Just 3 &amp;gt;&amp;gt;= (\x -&amp;gt; Just (x + 1))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これはもちろん&lt;code&gt;Just 4&lt;/code&gt;を返す。&lt;/p&gt;
&lt;p&gt;実際、bindはfish演算子や&lt;code&gt;join&lt;/code&gt;より使いやすい。
でも、結局bindでやっていることはfish演算子や&lt;code&gt;join&lt;/code&gt;を使って遠回りしてできることと同じだ。&lt;/p&gt;
&lt;p&gt;bind、fishと&lt;code&gt;join&lt;/code&gt;からお互いを作れることを示そう。
ここで&lt;code&gt;const&lt;/code&gt;と&lt;code&gt;id&lt;/code&gt;という関数を使っているが、それぞれ&lt;code&gt;const a b = a&lt;/code&gt;と&lt;code&gt;id a = a&lt;/code&gt;と定義される関数である。&lt;/p&gt;
&lt;p&gt;思い返せば、それぞれの型はこんな感じであった。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;join :: m (m a) -&amp;gt; m a
(&amp;gt;=&amp;gt;) :: (a -&amp;gt; m b) -&amp;gt; (b -&amp;gt; m c) -&amp;gt; (a -&amp;gt; m c)
(&amp;gt;&amp;gt;=) :: m a -&amp;gt; (a -&amp;gt; m b) -&amp;gt; m b
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;そこで、まず&lt;code&gt;join&lt;/code&gt;を作ってみよう。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;join x = x &amp;gt;&amp;gt;= id
join x = const x &amp;gt;=&amp;gt; id
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上は&lt;code&gt;m (m a)&lt;/code&gt;型の変数を取っている。
&lt;code&gt;id&lt;/code&gt;は&lt;code&gt;a -&amp;gt; a&lt;/code&gt;の関数なので、&lt;/p&gt;

    </description>
    </item>
    
    <item>
    <title>The Road to Monads: Applicativeについて</title>
    <link>https://miso.sabanium.me/post/applicative/</link>
    <pubDate>Sun, 05 Dec 2021 11:22:10 +0900</pubDate>
    <author>sabanium</author>
    <guid>https://miso.sabanium.me/post/applicative/</guid>
    <description>
        &lt;p&gt;この記事は&lt;a href=&#34;https://oliverbalfour.github.io/haskell/2020/08/06/applicative-functors.html&#34;&gt;The Road to Monads&lt;/a&gt;を意訳したものであり、&lt;a href=&#34;https://adventar.org/calendars/6389&#34;&gt;RICORA Advent Calendar&lt;/a&gt;の9日目の記事です。&lt;/p&gt;
&lt;h2 id=&#34;applicative-functor&#34;&gt;
    &lt;a href=&#34;#applicative-functor&#34; class=&#34;anchor&#34;&gt;
        &lt;svg class=&#34;icon&#34; aria-hidden=&#34;true&#34; focusable=&#34;false&#34; height=&#34;16&#34; version=&#34;1.1&#34; viewBox=&#34;0 0 16 16&#34; width=&#34;16&#34;&gt;
            &lt;path fill-rule=&#34;evenodd&#34;
                d=&#34;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&#34;&gt;
            &lt;/path&gt;
        &lt;/svg&gt;
    &lt;/a&gt;
    Applicative Functor
&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://miso.sabanium.me/post/functor&#34;&gt;Functor&lt;/a&gt;はWrapperで、fmapを使えば&lt;code&gt;(a -&amp;gt; b)-&amp;gt;(f a -&amp;gt; f b)&lt;/code&gt;という風にFunctorの要素に対して関数を適用できたのだった。
もちろん、これはカリー化されているので結局&lt;code&gt;(a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b&lt;/code&gt;と同じことである。&lt;/p&gt;
&lt;p&gt;でもこれだと問題があって、例えば&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;f :: Int -&amp;gt; Int -&amp;gt; Int
f a b = a * b
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;みたいな関数を&lt;code&gt;Maybe Int&lt;/code&gt;で置き換えて使おうと思ったときに使えない。
というか単純に一変数関数にしか使えん。
これはけっこうだるい。&lt;/p&gt;
&lt;p&gt;そこで、その代替策がApplicativeなのだがこれもこれとして理解し難い。
まずは関数定義から見てみよう。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class functor f =&amp;gt; Applicative f where
  pure :: a -&amp;gt; f a
  (&amp;lt;*&amp;gt;) :: f (a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ここで()に囲まれているのは中置関数（ここでは演算子とよぶ）であることを思い出そう。
すると、まず&lt;code&gt;pure&lt;/code&gt;はある型&lt;code&gt;a&lt;/code&gt;から&lt;code&gt;Functor a&lt;/code&gt;型に移すようなものだとわかる。
&lt;code&gt;pure&lt;/code&gt;はfunctorのデフォルトであるべき（らしい）なので、簡単な例だと&lt;code&gt;Maybe&lt;/code&gt;に対して&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pure a -&amp;gt; Just a
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;である。どこが&lt;code&gt;pure&lt;/code&gt;なのかはいまいちよくわからない。&lt;/p&gt;
&lt;p&gt;Haskellでは関数も型なので、こういうこともできる。ある項+1を取れば、&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pure (+1) -&amp;gt; Just (+1)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;この&lt;code&gt;Just(+1)&lt;/code&gt;の型は&lt;code&gt;Maybe(a -&amp;gt; a)&lt;/code&gt;である。&lt;/p&gt;
&lt;p&gt;うん。まあなんとなくはわかった感がある。&lt;/p&gt;
&lt;p&gt;次は&lt;code&gt;(&amp;lt;*&amp;gt;)&lt;/code&gt;について。
なにこいつ、なまこっぽいみたいな感想が先に立つけどまあうん。
実はよく見ると&lt;code&gt;fmap&lt;/code&gt;に似ていることがわかる。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;fmap :: (a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b
&amp;lt;*&amp;gt; :: f (a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ここでの違いは、もう関数がFunctorに埋め込まれているかどうかだけ。&lt;/p&gt;
&lt;p&gt;だから実は&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pure a -&amp;gt; f a
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;を思い出せば、型システムから&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;fmap f x = pure f &amp;lt;*&amp;gt; x
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;であることがわかる。&lt;/p&gt;
&lt;p&gt;具体例を作ってみよう。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;fn :: a -&amp;gt; b
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;に対して&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pure fn :: f (a -&amp;gt; b) 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;なので、&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pure fn &amp;lt;*&amp;gt; :: a -&amp;gt; f b
fmap fn :: a -&amp;gt; f b
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;がいえる。ふう。もちろん、ここで&lt;code&gt;f&lt;/code&gt;はFunctorの型で&lt;code&gt;a&lt;/code&gt;は関数の引数である。&lt;/p&gt;
&lt;p&gt;いや、なんの役に立つねん。
うーんと、実はなまこ&lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;の重要性は関数を取ることにある。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;の引数は&lt;code&gt;f(a -&amp;gt; b)&lt;/code&gt;といってるけど、この&lt;code&gt;b&lt;/code&gt;が&lt;code&gt;c -&amp;gt; d -&amp;gt; e&lt;/code&gt;型だった場合について考えよう。
一回&lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;を適用すると、返り値は&lt;code&gt;f b&lt;/code&gt;だけどこれは実際には&lt;code&gt;f( c -&amp;gt; d -&amp;gt; e )&lt;/code&gt;の型。
あれ？これってさっきと同じ形じゃない？
そう、そのとおりで、&lt;code&gt;c&lt;/code&gt;を&lt;code&gt;a&lt;/code&gt;、&lt;code&gt;d -&amp;gt; e&lt;/code&gt;を&lt;code&gt;b&lt;/code&gt;と置き換えると、&lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;をもう一回適用することで&lt;code&gt;f(d -&amp;gt; e)&lt;/code&gt;がでて、結局&lt;code&gt;f e&lt;/code&gt;の値が出ることになる。
その過程で、入力に&lt;code&gt;f a&lt;/code&gt;、&lt;code&gt;f b&lt;/code&gt;、&lt;code&gt;f c&lt;/code&gt;、&lt;code&gt;f d&lt;/code&gt;の値が必要になる。
これって引数が多い関数じゃない？そう。
だから再帰的なアプローチを関数に対して取ることで（！？）うまく引数の多い関数を実装できるような仕組みができているのだった。
まあ、正直に言えばカリー化そのものなんだけど、カリー化はFunctorの中でも動かせるよねという話。&lt;/p&gt;
&lt;h3 id=&#34;具体例&#34;&gt;
    &lt;a href=&#34;#%e5%85%b7%e4%bd%93%e4%be%8b&#34; class=&#34;anchor&#34;&gt;
        &lt;svg class=&#34;icon&#34; aria-hidden=&#34;true&#34; focusable=&#34;false&#34; height=&#34;16&#34; version=&#34;1.1&#34; viewBox=&#34;0 0 16 16&#34; width=&#34;16&#34;&gt;
            &lt;path fill-rule=&#34;evenodd&#34;
                d=&#34;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&#34;&gt;
            &lt;/path&gt;
        &lt;/svg&gt;
    &lt;/a&gt;
    具体例
&lt;/h3&gt;
&lt;p&gt;具体的な例を見よう。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pure (+) &amp;lt;*&amp;gt; Just a &amp;lt;*&amp;gt; Just b
== (Just (+) &amp;lt;*&amp;gt; Just a) &amp;lt;*&amp;gt; Just b
== Just (+a) &amp;lt;*&amp;gt; Just b
== Just (a+b)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ここで型を確かめておけば、&lt;code&gt;Just (+a) :: Maybe (Int -&amp;gt; Int)&lt;/code&gt;なので、&lt;code&gt;&amp;lt;*&amp;gt; :: f (Int -&amp;gt; Int) -&amp;gt; f Int -&amp;gt; f Int&lt;/code&gt;に対して&lt;code&gt;f Int&lt;/code&gt;である&lt;code&gt;Just (a+b)&lt;/code&gt;がちゃんと返ってくれる。
これは別に&lt;code&gt;fmap&lt;/code&gt;でもいい気もするがそれはさておき。&lt;/p&gt;
&lt;p&gt;また、こんな関数を考えると&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;quadratic :: Int -&amp;gt; Int -&amp;gt; Int -&amp;gt; Int -&amp;gt; Int
quadratic a b c x = a * x ^ 2 + b * x + c
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;pure&lt;/code&gt;と&lt;code&gt;fmap&lt;/code&gt;で書いたこれらが等価であることがわかる。
&lt;code&gt;&amp;lt;$&amp;gt;&lt;/code&gt;は&lt;code&gt;fmap&lt;/code&gt;の略記。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;quadratic &amp;lt;$&amp;gt; (Just 3) &amp;lt;*&amp;gt; (Just 4) &amp;lt;*&amp;gt; (Just (-2)) &amp;lt;*&amp;gt; (Just 9)
pure quadratic &amp;lt;*&amp;gt; (Just 3) &amp;lt;*&amp;gt; (Just 4) &amp;lt;*&amp;gt; (Just (-2)) &amp;lt;*&amp;gt; (Just 9)
== Just(quadratic 3 4 (-2) 9)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;さらにApplicative Functorで書いた&lt;code&gt;Maybe&lt;/code&gt;、&lt;code&gt;Applicative Maybe&lt;/code&gt;についても考えることができる
（バナナのナス、バナナスみたいだ）。
&lt;code&gt;Nothing&lt;/code&gt;が片方の項にあるなら&lt;code&gt;Nothing&lt;/code&gt;、それ以外は&lt;code&gt;Just&lt;/code&gt;を返せばいいので&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;instance Applicative Maybe where
  pure = Just
  (Just f) &amp;lt;*&amp;gt; (Just x) = Just (f x)
  _ &amp;lt;*&amp;gt; _ = Nothing
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;はい。
定義に沿った結果が返せているのでいい感じだね。&lt;/p&gt;
&lt;p&gt;具体例についてはまたどっかで追記するかもしれない。&lt;/p&gt;
&lt;h3 id=&#34;法則について&#34;&gt;
    &lt;a href=&#34;#%e6%b3%95%e5%89%87%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6&#34; class=&#34;anchor&#34;&gt;
        &lt;svg class=&#34;icon&#34; aria-hidden=&#34;true&#34; focusable=&#34;false&#34; height=&#34;16&#34; version=&#34;1.1&#34; viewBox=&#34;0 0 16 16&#34; width=&#34;16&#34;&gt;
            &lt;path fill-rule=&#34;evenodd&#34;
                d=&#34;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&#34;&gt;
            &lt;/path&gt;
        &lt;/svg&gt;
    &lt;/a&gt;
    法則について
&lt;/h3&gt;
&lt;p&gt;守らなきゃいけない法則がある。
これはHaskellというよりは、圏論からの要請っぽい。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;恒等的な関数の存在&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  pure id &amp;lt;*&amp;gt; x == x
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これはFunctor側の&lt;code&gt;fmap&lt;/code&gt;で確かめられていても、こっちで確かめなきゃいけない。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;合成則&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  pure (.) &amp;lt;*&amp;gt; u &amp;lt;*&amp;gt; v &amp;lt;*&amp;gt; w == u &amp;lt;*&amp;gt; (v &amp;lt;*&amp;gt; w)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;うーんと、何が言いたいかいまいちよくわからない感じがするけど&lt;code&gt;(u . v) w == u (v w)&lt;/code&gt;とFunctorなしの表記にするとわかりやすいのかな。
ここで&lt;code&gt;u&lt;/code&gt;と&lt;code&gt;v&lt;/code&gt;はapplicative functorの中の関数なので、先に関数を合成して計算しても、関数の結果に関数を適用しても値が同じことを保証しなければならないことを言っている。
参照透過性とかと関係あるかは不明。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;準同型&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  pure f &amp;lt;*&amp;gt; pure x == pure (f x)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;気持ち的には自明っていいたい！が証明は必要。
&lt;code&gt;pure f &amp;lt;*&amp;gt; y&lt;/code&gt;とすれば、&lt;code&gt;f y&lt;/code&gt;から&lt;code&gt;f (f x)&lt;/code&gt;より&lt;code&gt;pure (f x)&lt;/code&gt;っぽい。&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;交換則&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  f &amp;lt;*&amp;gt; pure x == pure ($ x) &amp;lt;*&amp;gt; f
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;割と意味わからん。ここはあとで追記。&lt;/p&gt;
&lt;h3 id=&#34;補足&#34;&gt;
    &lt;a href=&#34;#%e8%a3%9c%e8%b6%b3&#34; class=&#34;anchor&#34;&gt;
        &lt;svg class=&#34;icon&#34; aria-hidden=&#34;true&#34; focusable=&#34;false&#34; height=&#34;16&#34; version=&#34;1.1&#34; viewBox=&#34;0 0 16 16&#34; width=&#34;16&#34;&gt;
            &lt;path fill-rule=&#34;evenodd&#34;
                d=&#34;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&#34;&gt;
            &lt;/path&gt;
        &lt;/svg&gt;
    &lt;/a&gt;
    補足
&lt;/h3&gt;
&lt;p&gt;要はApplicative Functorは一つの国みたいなもので、&lt;code&gt;pure&lt;/code&gt;はそこに連れて行くためのコンストラクタ、&lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;はその中で関数を適用するための演算子として捉えるとわかりやすいのかな。&lt;/p&gt;
&lt;p&gt;おわり。&lt;/p&gt;

    </description>
    </item>
    
    <item>
    <title>The Road to Monads: Functorについて</title>
    <link>https://miso.sabanium.me/post/functor/</link>
    <pubDate>Sat, 04 Dec 2021 22:45:30 +0900</pubDate>
    <author>sabanium</author>
    <guid>https://miso.sabanium.me/post/functor/</guid>
    <description>
        &lt;p&gt;この記事は&lt;a href=&#34;https://oliverbalfour.github.io/haskell/2020/08/04/functors-in-haskell.html&#34;&gt;The Road to Monads&lt;/a&gt;を意訳したものです。
あんまり難しいことは言っていないと思うんだけど、あまり頭に入らなかったので簡単に翻訳してみた。&lt;/p&gt;
&lt;h2 id=&#34;functor&#34;&gt;
    &lt;a href=&#34;#functor&#34; class=&#34;anchor&#34;&gt;
        &lt;svg class=&#34;icon&#34; aria-hidden=&#34;true&#34; focusable=&#34;false&#34; height=&#34;16&#34; version=&#34;1.1&#34; viewBox=&#34;0 0 16 16&#34; width=&#34;16&#34;&gt;
            &lt;path fill-rule=&#34;evenodd&#34;
                d=&#34;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&#34;&gt;
            &lt;/path&gt;
        &lt;/svg&gt;
    &lt;/a&gt;
    Functor
&lt;/h2&gt;
&lt;h3 id=&#34;fmap&#34;&gt;
    &lt;a href=&#34;#fmap&#34; class=&#34;anchor&#34;&gt;
        &lt;svg class=&#34;icon&#34; aria-hidden=&#34;true&#34; focusable=&#34;false&#34; height=&#34;16&#34; version=&#34;1.1&#34; viewBox=&#34;0 0 16 16&#34; width=&#34;16&#34;&gt;
            &lt;path fill-rule=&#34;evenodd&#34;
                d=&#34;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&#34;&gt;
            &lt;/path&gt;
        &lt;/svg&gt;
    &lt;/a&gt;
    fmap
&lt;/h3&gt;
&lt;p&gt;Functorって何? 内部の値にアクセスできるようにしたWrapper。具体例: IO、Maybeなど。
圏論でいうところの関手。&lt;/p&gt;
&lt;p&gt;コードでの具体例：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;addMaybe :: Num a =&amp;gt; Maybe a -&amp;gt; Maybe a -&amp;gt; Maybe a
addMaybe (Just a) (Just b) = Just (a + b)
addMaybe _ _ = Nothing
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;確かに内部の値にアクセスしている。まあこれは恣意的な関数だけど。
ただし、これを一般化するといい感じになってくれる。
要は内部の値にアクセスすることが重要で、例えばf :: Int -&amp;gt; Intはこういう関数を使うことでMaybe Intにも使えるようになったりする。&lt;/p&gt;
&lt;p&gt;次に、こんな関数を考える。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;fmapList :: (a -&amp;gt; b) -&amp;gt; ([a] -&amp;gt; [b])
fmapList f [] = []
fmapList f (x:xs) = f x : fmapList f xs
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これはmap関数と変わらない。
ある関数をリストのすべての要素に適用するだけだ。&lt;/p&gt;
&lt;p&gt;では、これを一般化するとどうなるだろう？
つまり、こんな感じの関数たちを統一的に記述できるだろうか？&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;f :: (a -&amp;gt; b) -&amp;gt; ((Just a) -&amp;gt; (Just b))
f2 :: (a -&amp;gt; b) -&amp;gt; ([a] -&amp;gt; [b])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;その関数が、functorと紐付けられたfmapである。
技術的にはfunctorはFunctor型クラスでfmapと紐付いたインスタンス。
ただし、満たすべき条件があり、それがこれ。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;fmap id == id (恒等的であること)&lt;/li&gt;
&lt;li&gt;fmap (f . g) == fmap f . fmap g (分配的であること)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;じゃあlistとMaybeの実装を見てみよう。&lt;/p&gt;
&lt;p&gt;PreludeのリストのFunctorの実装はこんな感じ。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;instance Functor [] where
  fmap = map
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上で見たとおり、fmapListはmapと同じなのだった。
mapはpythonとかの同名の関数と同じで、ある関数をリストの全要素に適用する関数。
いや、さすがにこれだとわからなくない？&lt;/p&gt;
&lt;p&gt;次にMaybeを見よう。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;instance Functor Maybe where
  fmap f (Just x) = Just (f x)
  fmap _ Nothing = Nothing
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;こっちの方が解釈はしやすい。fとJust xがあるなら、返り値（？）を(Just f x)として呼ぶことにしている。&lt;/p&gt;
&lt;p&gt;まあまあわかるような気もする。
他には、&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;data BinaryTree a = Node a (BinaryTree a) (BinaryTree a) | Leaf a
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;こんな感じのBinaryTree型を使うとき、fmapは&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;instance Functor BinaryTree where
  fmap f (Node x left right) = Node (f x) (fmap f left) (fmap f right)
  fmap f (Leaf x) = Leaf (f x)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;という感じになる。&lt;/p&gt;
&lt;p&gt;Functorというかfmapのいいところは、Wrapperの存在を意識せずに書けるところっぽい。&lt;/p&gt;

    </description>
    </item>
    
    <item>
    <title>Haskell覚え書き</title>
    <link>https://miso.sabanium.me/post/c-haskell1/</link>
    <pubDate>Sat, 04 Dec 2021 00:00:00 +0000</pubDate>
    <author>sabanium</author>
    <guid>https://miso.sabanium.me/post/c-haskell1/</guid>
    <description>
        &lt;p&gt;構文解析のためのモナド等についてまとめる。完全に自分用。&lt;/p&gt;
&lt;h3 id=&#34;haskellの文法について&#34;&gt;
    &lt;a href=&#34;#haskell%e3%81%ae%e6%96%87%e6%b3%95%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6&#34; class=&#34;anchor&#34;&gt;
        &lt;svg class=&#34;icon&#34; aria-hidden=&#34;true&#34; focusable=&#34;false&#34; height=&#34;16&#34; version=&#34;1.1&#34; viewBox=&#34;0 0 16 16&#34; width=&#34;16&#34;&gt;
            &lt;path fill-rule=&#34;evenodd&#34;
                d=&#34;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&#34;&gt;
            &lt;/path&gt;
        &lt;/svg&gt;
    &lt;/a&gt;
    Haskellの文法について
&lt;/h3&gt;
&lt;p&gt;よく見るやつ&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;型拘束&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;(Ord a) =&amp;gt; a -&amp;gt; a
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;要素の存在&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;(x:xs)
&lt;/code&gt;&lt;/pre&gt;
    </description>
    </item>
    
    <item>
    <title>HaskellでCコンパイラもどきを作る #0</title>
    <link>https://miso.sabanium.me/post/c-haskell0/</link>
    <pubDate>Fri, 03 Dec 2021 00:00:00 +0000</pubDate>
    <author>sabanium</author>
    <guid>https://miso.sabanium.me/post/c-haskell0/</guid>
    <description>
        &lt;p&gt;まず環境構築をする。&lt;/p&gt;
&lt;h3 id=&#34;haskellのインストール&#34;&gt;
    &lt;a href=&#34;#haskell%e3%81%ae%e3%82%a4%e3%83%b3%e3%82%b9%e3%83%88%e3%83%bc%e3%83%ab&#34; class=&#34;anchor&#34;&gt;
        &lt;svg class=&#34;icon&#34; aria-hidden=&#34;true&#34; focusable=&#34;false&#34; height=&#34;16&#34; version=&#34;1.1&#34; viewBox=&#34;0 0 16 16&#34; width=&#34;16&#34;&gt;
            &lt;path fill-rule=&#34;evenodd&#34;
                d=&#34;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&#34;&gt;
            &lt;/path&gt;
        &lt;/svg&gt;
    &lt;/a&gt;
    Haskellのインストール
&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.haskell.org/downloads/&#34;&gt;これ&lt;/a&gt;を読んで、GHCupとHaskell Tool Stackの一番上の方にのってるcurlコマンドを叩く。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;curl --proto &#39;=https&#39; --tlsv1.2 -sSf https://get-ghcup.haskell.org | sh
curl -sSL https://get.haskellstack.org/ | sh
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;LSPは必要なので入れて、それ以外のものにも大体Yesと回答した気がする。なんかPとか押させるのが厄介。&lt;/p&gt;
&lt;h3 id=&#34;haskell-language-serverの導入&#34;&gt;
    &lt;a href=&#34;#haskell-language-server%e3%81%ae%e5%b0%8e%e5%85%a5&#34; class=&#34;anchor&#34;&gt;
        &lt;svg class=&#34;icon&#34; aria-hidden=&#34;true&#34; focusable=&#34;false&#34; height=&#34;16&#34; version=&#34;1.1&#34; viewBox=&#34;0 0 16 16&#34; width=&#34;16&#34;&gt;
            &lt;path fill-rule=&#34;evenodd&#34;
                d=&#34;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&#34;&gt;
            &lt;/path&gt;
        &lt;/svg&gt;
    &lt;/a&gt;
    Haskell Language Serverの導入
&lt;/h3&gt;
&lt;p&gt;vim-lsp-settingsはHaskell Language Server(以下HLS)に対応していないがvim-lsp-settingsの&lt;a href=&#34;https://github.com/mattn/vim-lsp-settings/issues/309&#34;&gt;issue&lt;/a&gt;を読むとそういうことが書いてあるので.vimrcを適当にいじるとうまくHLSが動く。&lt;/p&gt;
&lt;p&gt;これでGHC+HLSが入った環境が準備できた。&lt;/p&gt;

    </description>
    </item>
    
  </channel>
</rss>
