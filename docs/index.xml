<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>鯖の味噌煮がおいしく炊けない</title>
    <link>https://miso.sabanium.me/</link>
    <description>Recent content on 鯖の味噌煮がおいしく炊けない</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-JP</language>
    <lastBuildDate>Mon, 06 Dec 2021 11:20:40 +0900</lastBuildDate><atom:link href="https://miso.sabanium.me/index.xml" rel="self" type="application/rss+xml" />
    <item>
    <title>The Road to Monads: Monadについて</title>
    <link>https://miso.sabanium.me/post/monad/</link>
    <pubDate>Mon, 06 Dec 2021 11:20:40 +0900</pubDate>
    <author>sabanium</author>
    <guid>https://miso.sabanium.me/post/monad/</guid>
    <description>
        &lt;p&gt;この記事は&lt;a href=&#34;https://oliverbalfour.github.io/haskell/2020/08/08/understanding-monads-haskell.html&#34;&gt;The Road to Monads&lt;/a&gt;を意訳したものであり、&lt;a href=&#34;https://adventar.org/calendars/6389&#34;&gt;RICORA Advent Calendar&lt;/a&gt;の11日目の記事です。&lt;/p&gt;
&lt;h2 id=&#34;monad&#34;&gt;
    &lt;a href=&#34;#monad&#34; class=&#34;anchor&#34;&gt;
        &lt;svg class=&#34;icon&#34; aria-hidden=&#34;true&#34; focusable=&#34;false&#34; height=&#34;16&#34; version=&#34;1.1&#34; viewBox=&#34;0 0 16 16&#34; width=&#34;16&#34;&gt;
            &lt;path fill-rule=&#34;evenodd&#34;
                d=&#34;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&#34;&gt;
            &lt;/path&gt;
        &lt;/svg&gt;
    &lt;/a&gt;
    Monad
&lt;/h2&gt;
&lt;p&gt;今までの流れを振り返ると、&lt;a href=&#34;https://miso.sabanium.me/post/functor&#34;&gt;Functor&lt;/a&gt;は何らかの値のWrapperであり、&lt;code&gt;fmap&lt;/code&gt;によってその要素に関数適用ができた。
&lt;a href=&#34;https://miso.sabanium.me/post/applicative&#34;&gt;Applicative Functor&lt;/a&gt;はそれをさらに発展させて、関数自体をFunctorで包むことによって、複数の引数を取る関数を実装できるようにしていたのだった。&lt;/p&gt;
&lt;p&gt;さて、何が足りないのだろう？
実は、Applicative Functorだけでは関数を複数組み合わせることが難しい。
例えば、&lt;code&gt;f :: a -&amp;gt; b&lt;/code&gt;と&lt;code&gt;g :: b -&amp;gt; c&lt;/code&gt;があったときに、Applicative Functorだと&lt;code&gt;a -&amp;gt; f b&lt;/code&gt;、&lt;code&gt;b -&amp;gt; f c&lt;/code&gt;に写すことはできても&lt;code&gt;a -&amp;gt; f c&lt;/code&gt;に写すことができない。
こういう関数の使い方をする機会は割と多い気がするし、こんな感じで書きたくない？という話。&lt;/p&gt;
&lt;p&gt;簡単にいえば、MonadはFunctorの中での関数合成を可能にする構造。
しかし、これだけだとMonadが実際に何をするかいまいちわからないので以下に書いていく。
導入として、大体FunctorみたいなものだとしてMonad&lt;code&gt;m&lt;/code&gt;を使うことにしよう。&lt;/p&gt;
&lt;p&gt;じつはMonadは他の必要っぽいことも包摂してくれている。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Monad上の関数の繰り返し適用に対して、Monadを圧縮する。&lt;code&gt;a -&amp;gt; m b&lt;/code&gt;に対してまたfmapをつかって&lt;code&gt;m&lt;/code&gt;を適用すると、&lt;code&gt;m a -&amp;gt; m (m -&amp;gt; b)&lt;/code&gt;になってしまう。
例えば、&lt;code&gt;a -&amp;gt; Maybe b&lt;/code&gt;なら&lt;code&gt;Maybe a -&amp;gt; Maybe ( Maybe b )&lt;/code&gt;的な。
これを圧縮して、繰り返し適用しても&lt;code&gt;a -&amp;gt; Maybe b&lt;/code&gt;の型を作れるようにする。&lt;/li&gt;
&lt;li&gt;さっきの例。
&lt;code&gt;a -&amp;gt; m b&lt;/code&gt;と&lt;code&gt;b -&amp;gt; m c&lt;/code&gt;から&lt;code&gt;a -&amp;gt; m c&lt;/code&gt;の関数を作りだせる。&lt;/li&gt;
&lt;li&gt;逆に&lt;code&gt;m a&lt;/code&gt;が与えられたとき、&lt;code&gt;a -&amp;gt; m b&lt;/code&gt;の関数を使えるようにする。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;型の圧縮&#34;&gt;
    &lt;a href=&#34;#%e5%9e%8b%e3%81%ae%e5%9c%a7%e7%b8%ae&#34; class=&#34;anchor&#34;&gt;
        &lt;svg class=&#34;icon&#34; aria-hidden=&#34;true&#34; focusable=&#34;false&#34; height=&#34;16&#34; version=&#34;1.1&#34; viewBox=&#34;0 0 16 16&#34; width=&#34;16&#34;&gt;
            &lt;path fill-rule=&#34;evenodd&#34;
                d=&#34;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&#34;&gt;
            &lt;/path&gt;
        &lt;/svg&gt;
    &lt;/a&gt;
    型の圧縮
&lt;/h3&gt;
&lt;p&gt;まあこれだけだとよくわからないので、具体例を考えよう。
&lt;code&gt;1 / sqrt (x)&lt;/code&gt;を&lt;code&gt;Maybe&lt;/code&gt;を返すとして考える。
この関数を二つの関数&lt;code&gt;1 / x&lt;/code&gt;と&lt;code&gt;sqrt(x)&lt;/code&gt;の合成で考えるとすると、例えば&lt;code&gt;1/0&lt;/code&gt;はundefinedなので、&lt;code&gt;1 / x&lt;/code&gt;で&lt;code&gt;x = 0&lt;/code&gt;なら&lt;code&gt;Nothing&lt;/code&gt;を返したい。
これは&lt;code&gt;sqrt(x)&lt;/code&gt;でも一緒。&lt;code&gt;x &amp;lt; 0&lt;/code&gt;なら&lt;code&gt;Nothing&lt;/code&gt;を返したい。
そこで、これらを実際に書いてみるとこんな感じ。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;safeInverse :: Double -&amp;gt; Maybe Double
safeInverse 0 = Nothing
safeInverse _ = Just(1/x)

safeSqrt :: Double -&amp;gt; Maybe Double
safeSqrt x = case signum x of
  (-1) -&amp;gt; Nothing
  _ -&amp;gt; Just (sqrt x)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ここで&lt;code&gt;signum&lt;/code&gt;は符号を返す関数。&lt;/p&gt;
&lt;p&gt;まあこれだけで完結するんだったらいいんだけど、もっとでかいプログラムの一部に組み込むなら&lt;code&gt;Maybe&lt;/code&gt;の場合分けをし続けることになる。
めんどくさい犬の散歩みたいだ。
&lt;code&gt;fmap&lt;/code&gt;をつかってもいいかもしれないけど、&lt;code&gt;fmap&lt;/code&gt;を使うと&lt;code&gt;1 / sqrt(x)&lt;/code&gt;の関数の型が&lt;code&gt;a -&amp;gt; Maybe (Maybe b)&lt;/code&gt;になってしまう。
これをもっとでかい関数の一部として使うとすると&amp;hellip;大変なことになりそうだ。&lt;/p&gt;
&lt;p&gt;それを避けるために、&lt;code&gt;join&lt;/code&gt;という関数を考える。
&lt;code&gt;Maybe&lt;/code&gt;に対してはこんな感じで書ける。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;join :: Maybe (Maybe a) -&amp;gt; Maybe a
join (Just x) = x
join Nothing = Nothing
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これは圧縮そのものだから、実際に&lt;code&gt;1 / sqrt(x)&lt;/code&gt;を書くと&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sqrtInverse :: Double -&amp;gt; Maybe Double
sqrtInverse = join ( fmap safeInverse (safeSqrt x))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;こんな感じ。
確認だけど、&lt;code&gt;fmap SafeInverse (safeSqrt x)&lt;/code&gt;が&lt;code&gt;Double -&amp;gt; Maybe (Maybe Double)&lt;/code&gt;型の関数なので、&lt;code&gt;join&lt;/code&gt;を使うと&lt;code&gt;Double -&amp;gt; Maybe Double&lt;/code&gt;になる。&lt;/p&gt;
&lt;p&gt;この&lt;code&gt;join&lt;/code&gt;は実際にこんな感じに一般化できるらしい。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;join :: Monad m =&amp;gt; m (m a) -&amp;gt; m a
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;関数の合成&#34;&gt;
    &lt;a href=&#34;#%e9%96%a2%e6%95%b0%e3%81%ae%e5%90%88%e6%88%90&#34; class=&#34;anchor&#34;&gt;
        &lt;svg class=&#34;icon&#34; aria-hidden=&#34;true&#34; focusable=&#34;false&#34; height=&#34;16&#34; version=&#34;1.1&#34; viewBox=&#34;0 0 16 16&#34; width=&#34;16&#34;&gt;
            &lt;path fill-rule=&#34;evenodd&#34;
                d=&#34;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&#34;&gt;
            &lt;/path&gt;
        &lt;/svg&gt;
    &lt;/a&gt;
    関数の合成
&lt;/h3&gt;
&lt;p&gt;この&lt;code&gt;sqrtInverse&lt;/code&gt;を関数の合成の観点から見てみよう。
さっきと同じように普通の値を取ってMonad内部の値を返すような関数を二つ考えて、それらを普通の値を取ってMonadの値として返す関数を想定するとき、&lt;code&gt;&amp;gt;=&amp;gt;&lt;/code&gt;という演算子を使うことができる。
例えば&lt;code&gt;f :: a -&amp;gt; m b&lt;/code&gt;と&lt;code&gt;g :: b -&amp;gt; m c&lt;/code&gt;があるとき、&lt;code&gt;f &amp;gt;=&amp;gt; g&lt;/code&gt;は&lt;code&gt;a -&amp;gt; m c&lt;/code&gt;という型になる。
この&lt;code&gt;&amp;gt;=&amp;gt;&lt;/code&gt;演算子は魚に似ている（？）のでfish演算子と呼ばれ、この合成自体はKleisli(クライスリ)合成というらしい。&lt;/p&gt;
&lt;p&gt;実際にこのfish演算子が使われている所を見てみよう。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;(&amp;gt;=&amp;gt;) :: (a -&amp;gt; Maybe b) -&amp;gt; (b -&amp;gt; Maybe c) -&amp;gt; (a -&amp;gt; Maybe c)
f &amp;gt;=&amp;gt; g = \x -&amp;gt; case f x of
  Just x -&amp;gt; g x
  Nothing -&amp;gt; Nothing
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;うん。
まず一行目はfish演算子を定義した通りの定義になっている。
そこで、二行目以降ではMonadがMaybeなので、&lt;code&gt;f x&lt;/code&gt;は&lt;code&gt;Just x&lt;/code&gt;か&lt;code&gt;Nothing&lt;/code&gt;を返し、&lt;code&gt;Just x&lt;/code&gt;ならunwrapして&lt;code&gt;g x&lt;/code&gt;を返すようにパターンマッチングしてあげている。&lt;/p&gt;
&lt;p&gt;このfish演算子を実際にさっきの&lt;code&gt;sqrtInverse&lt;/code&gt;に使おう。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sqrtInverse :: Double -&amp;gt; Maybe Double
sqrtInverse = safeSqrt &amp;gt;=&amp;gt; safeInverse
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;だいぶ短くなったし、これで明示的にパターンマッチングの処理をしなくてよくなったのでだいぶ見通しが良くなるはずだ。&lt;/p&gt;
&lt;p&gt;でもこれにはまだ問題がある。
Monadの中の値を使うときに恒等射的な関数を考える必要が出てくるのだ。
例えば&lt;code&gt;m a&lt;/code&gt;という値に対して&lt;code&gt;m a -&amp;gt; a&lt;/code&gt;という関数を作り、fish演算子を使う必要がある。
これだとまた型に合わせるための関数を作って見通しがまた良くなくなってしまう。&lt;/p&gt;
&lt;p&gt;実際にそういう例を見てみよう。
&lt;code&gt;const a b = a&lt;/code&gt;という関数を考えれば、&lt;code&gt;Just 5&lt;/code&gt;を計算するために&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;(const (Just 4) &amp;gt;=&amp;gt; (\x -&amp;gt; Just (x+1))) ()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;とする必要がある。
ごちゃごちゃしててわかりにくいから型を確かめよう。
&lt;code&gt;\x -&amp;gt; Just(x + 1)&lt;/code&gt;は&lt;code&gt;Int -&amp;gt; Maybe Int&lt;/code&gt;という型なので、fish演算子の引数を考えると&lt;code&gt;const (Just 4)&lt;/code&gt;は&lt;code&gt;Int -&amp;gt; Maybe Int&lt;/code&gt;という型のはず。
でも&lt;code&gt;Just 4&lt;/code&gt;は&lt;code&gt;Maybe Int&lt;/code&gt;型なので&amp;hellip;ここはあとで見返して追記します。&lt;/p&gt;
&lt;h3 id=&#34;連続的に計算させる&#34;&gt;
    &lt;a href=&#34;#%e9%80%a3%e7%b6%9a%e7%9a%84%e3%81%ab%e8%a8%88%e7%ae%97%e3%81%95%e3%81%9b%e3%82%8b&#34; class=&#34;anchor&#34;&gt;
        &lt;svg class=&#34;icon&#34; aria-hidden=&#34;true&#34; focusable=&#34;false&#34; height=&#34;16&#34; version=&#34;1.1&#34; viewBox=&#34;0 0 16 16&#34; width=&#34;16&#34;&gt;
            &lt;path fill-rule=&#34;evenodd&#34;
                d=&#34;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&#34;&gt;
            &lt;/path&gt;
        &lt;/svg&gt;
    &lt;/a&gt;
    連続的に計算させる
&lt;/h3&gt;
&lt;p&gt;では、別の演算子&lt;code&gt;(&amp;gt;&amp;gt;=) :: m a -&amp;gt; (a -&amp;gt; m b) -&amp;gt; m b&lt;/code&gt;を考えよう。
これをbind(演算子?)と呼ぶ。&lt;/p&gt;
&lt;p&gt;Maybeに対して実装するとこんな感じ。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;(&amp;gt;&amp;gt;=) :: Maybe a -&amp;gt; (a -&amp;gt; Maybe b) -&amp;gt; Maybe b
x (&amp;gt;&amp;gt;=) f = case x of
  (Just x&#39;) -&amp;gt; f x&#39;
  Nothing -&amp;gt; Nothing
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ここで&lt;code&gt;x&lt;/code&gt;は&lt;code&gt;Maybe x&#39;&lt;/code&gt;という型だとした。&lt;/p&gt;
&lt;p&gt;さっきの&lt;code&gt;sqrtInverse&lt;/code&gt;をまた拾ってこよう。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sqrtInverse :: Double -&amp;gt; Maybe Double
sqrtInverse x = safeSqrt x &amp;gt;&amp;gt;= safeInverse
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;他の例としてこういうのもある。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Just 3 &amp;gt;&amp;gt;= (\x -&amp;gt; Just (x + 1)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これはもちろん&lt;code&gt;Just 4&lt;/code&gt;を返す。&lt;/p&gt;
&lt;p&gt;実際、bindはfish演算子や&lt;code&gt;join&lt;/code&gt;より使いやすい。
でも、結局bindでやっていることはfish演算子や&lt;code&gt;join&lt;/code&gt;を使って遠回りしてできることと同じだ。&lt;/p&gt;
&lt;p&gt;bind、fishと&lt;code&gt;join&lt;/code&gt;からお互いを作れることを示そう。&lt;/p&gt;
&lt;p&gt;思い返せば、それぞれの型はこんな感じであった。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;join :: m (m a) -&amp;gt; m a
(&amp;gt;=&amp;gt;) :: (a -&amp;gt; m b) -&amp;gt; (b -&amp;gt; m c) -&amp;gt; (a -&amp;gt; m c)
(&amp;gt;&amp;gt;=) :: m a -&amp;gt; (a -&amp;gt; m b) -&amp;gt; m b
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;そこで、&lt;code&gt;join&lt;/code&gt;を作ってみよう。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;join x = x &amp;gt;&amp;gt;= id
join x = const x &amp;gt;=&amp;gt; id
&lt;/code&gt;&lt;/pre&gt;
    </description>
    </item>
    
    <item>
    <title>The Road to Monads: Applicativeについて</title>
    <link>https://miso.sabanium.me/post/applicative/</link>
    <pubDate>Sun, 05 Dec 2021 11:22:10 +0900</pubDate>
    <author>sabanium</author>
    <guid>https://miso.sabanium.me/post/applicative/</guid>
    <description>
        &lt;p&gt;この記事は&lt;a href=&#34;https://oliverbalfour.github.io/haskell/2020/08/06/applicative-functors.html&#34;&gt;The Road to Monads&lt;/a&gt;を意訳したものであり、&lt;a href=&#34;https://adventar.org/calendars/6389&#34;&gt;RICORA Advent Calendar&lt;/a&gt;の9日目の記事です。&lt;/p&gt;
&lt;h2 id=&#34;applicative-functor&#34;&gt;
    &lt;a href=&#34;#applicative-functor&#34; class=&#34;anchor&#34;&gt;
        &lt;svg class=&#34;icon&#34; aria-hidden=&#34;true&#34; focusable=&#34;false&#34; height=&#34;16&#34; version=&#34;1.1&#34; viewBox=&#34;0 0 16 16&#34; width=&#34;16&#34;&gt;
            &lt;path fill-rule=&#34;evenodd&#34;
                d=&#34;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&#34;&gt;
            &lt;/path&gt;
        &lt;/svg&gt;
    &lt;/a&gt;
    Applicative Functor
&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://miso.sabanium.me/post/functor&#34;&gt;Functor&lt;/a&gt;はWrapperで、fmapを使えば&lt;code&gt;(a -&amp;gt; b)-&amp;gt;(f a -&amp;gt; f b)&lt;/code&gt;という風にFunctorの要素に対して関数を適用できたのだった。
もちろん、これはカリー化されているので結局&lt;code&gt;(a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b&lt;/code&gt;と同じことである。&lt;/p&gt;
&lt;p&gt;でもこれだと問題があって、例えば&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;f :: Int -&amp;gt; Int -&amp;gt; Int
f a b = a * b
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;みたいな関数を&lt;code&gt;Maybe Int&lt;/code&gt;で置き換えて使おうと思ったときに使えない。
というか単純に一変数関数にしか使えん。
これはけっこうだるい。&lt;/p&gt;
&lt;p&gt;そこで、その代替策がApplicativeなのだがこれもこれとして理解し難い。
まずは関数定義から見てみよう。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class functor f =&amp;gt; Applicative f where
  pure :: a -&amp;gt; f a
  (&amp;lt;*&amp;gt;) :: f (a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ここで()に囲まれているのは中置関数（ここでは演算子とよぶ）であることを思い出そう。
すると、まず&lt;code&gt;pure&lt;/code&gt;はある型&lt;code&gt;a&lt;/code&gt;から&lt;code&gt;Functor a&lt;/code&gt;型に移すようなものだとわかる。
&lt;code&gt;pure&lt;/code&gt;はfunctorのデフォルトであるべき（らしい）なので、簡単な例だと&lt;code&gt;Maybe&lt;/code&gt;に対して&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pure a -&amp;gt; Just a
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;である。どこが&lt;code&gt;pure&lt;/code&gt;なのかはいまいちよくわからない。&lt;/p&gt;
&lt;p&gt;Haskellでは関数も型なので、こういうこともできる。ある項+1を取れば、&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pure (+1) -&amp;gt; Just (+1)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;この&lt;code&gt;Just(+1)&lt;/code&gt;の型は&lt;code&gt;Maybe(a -&amp;gt; a)&lt;/code&gt;である。&lt;/p&gt;
&lt;p&gt;うん。まあなんとなくはわかった感がある。&lt;/p&gt;
&lt;p&gt;次は&lt;code&gt;(&amp;lt;*&amp;gt;)&lt;/code&gt;について。
なにこいつ、なまこっぽいみたいな感想が先に立つけどまあうん。
実はよく見ると&lt;code&gt;fmap&lt;/code&gt;に似ていることがわかる。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;fmap :: (a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b
&amp;lt;*&amp;gt; :: f (a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ここでの違いは、もう関数がFunctorに埋め込まれているかどうかだけ。&lt;/p&gt;
&lt;p&gt;だから実は&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pure a -&amp;gt; f a
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;を思い出せば、型システムから&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;fmap f x = pure f &amp;lt;*&amp;gt; x
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;であることがわかる。&lt;/p&gt;
&lt;p&gt;具体例を作ってみよう。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;fn :: a -&amp;gt; b
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;に対して&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pure fn :: f (a -&amp;gt; b) 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;なので、&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pure fn &amp;lt;*&amp;gt; :: a -&amp;gt; f b
fmap fn :: a -&amp;gt; f b
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;がいえる。ふう。もちろん、ここで&lt;code&gt;f&lt;/code&gt;はFunctorの型で&lt;code&gt;a&lt;/code&gt;は関数の引数である。&lt;/p&gt;
&lt;p&gt;いや、なんの役に立つねん。
うーんと、実はなまこ&lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;の重要性は関数を取ることにある。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;の引数は&lt;code&gt;f(a -&amp;gt; b)&lt;/code&gt;といってるけど、この&lt;code&gt;b&lt;/code&gt;が&lt;code&gt;c -&amp;gt; d -&amp;gt; e&lt;/code&gt;型だった場合について考えよう。
一回&lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;を適用すると、返り値は&lt;code&gt;f b&lt;/code&gt;だけどこれは実際には&lt;code&gt;f( c -&amp;gt; d -&amp;gt; e )&lt;/code&gt;の型。
あれ？これってさっきと同じ形じゃない？
そう、そのとおりで、&lt;code&gt;c&lt;/code&gt;を&lt;code&gt;a&lt;/code&gt;、&lt;code&gt;d -&amp;gt; e&lt;/code&gt;を&lt;code&gt;b&lt;/code&gt;と置き換えると、&lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;をもう一回適用することで&lt;code&gt;f(d -&amp;gt; e)&lt;/code&gt;がでて、結局&lt;code&gt;f e&lt;/code&gt;の値が出ることになる。
その過程で、入力に&lt;code&gt;f a&lt;/code&gt;、&lt;code&gt;f b&lt;/code&gt;、&lt;code&gt;f c&lt;/code&gt;、&lt;code&gt;f d&lt;/code&gt;の値が必要になる。
これって引数が多い関数じゃない？そう。
だから再帰的なアプローチを関数に対して取ることで（！？）うまく引数の多い関数を実装できるような仕組みができているのだった。
まあ、正直に言えばカリー化そのものなんだけど、カリー化はFunctorの中でも動かせるよねという話。&lt;/p&gt;
&lt;h3 id=&#34;具体例&#34;&gt;
    &lt;a href=&#34;#%e5%85%b7%e4%bd%93%e4%be%8b&#34; class=&#34;anchor&#34;&gt;
        &lt;svg class=&#34;icon&#34; aria-hidden=&#34;true&#34; focusable=&#34;false&#34; height=&#34;16&#34; version=&#34;1.1&#34; viewBox=&#34;0 0 16 16&#34; width=&#34;16&#34;&gt;
            &lt;path fill-rule=&#34;evenodd&#34;
                d=&#34;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&#34;&gt;
            &lt;/path&gt;
        &lt;/svg&gt;
    &lt;/a&gt;
    具体例
&lt;/h3&gt;
&lt;p&gt;具体的な例を見よう。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pure (+) &amp;lt;*&amp;gt; Just a &amp;lt;*&amp;gt; Just b
== (Just (+) &amp;lt;*&amp;gt; Just a) &amp;lt;*&amp;gt; Just b
== Just (+a) &amp;lt;*&amp;gt; Just b
== Just (a+b)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ここで型を確かめておけば、&lt;code&gt;Just (+a) :: Maybe (Int -&amp;gt; Int)&lt;/code&gt;なので、&lt;code&gt;&amp;lt;*&amp;gt; :: f (Int -&amp;gt; Int) -&amp;gt; f Int -&amp;gt; f Int&lt;/code&gt;に対して&lt;code&gt;f Int&lt;/code&gt;である&lt;code&gt;Just (a+b)&lt;/code&gt;がちゃんと返ってくれる。
これは別に&lt;code&gt;fmap&lt;/code&gt;でもいい気もするがそれはさておき。&lt;/p&gt;
&lt;p&gt;また、こんな関数を考えると&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;quadratic :: Int -&amp;gt; Int -&amp;gt; Int -&amp;gt; Int -&amp;gt; Int
quadratic a b c x = a * x ^ 2 + b * x + c
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;pure&lt;/code&gt;と&lt;code&gt;fmap&lt;/code&gt;で書いたこれらが等価であることがわかる。
&lt;code&gt;&amp;lt;$&amp;gt;&lt;/code&gt;は&lt;code&gt;fmap&lt;/code&gt;の略記。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;quadratic &amp;lt;$&amp;gt; (Just 3) &amp;lt;*&amp;gt; (Just 4) &amp;lt;*&amp;gt; (Just (-2)) &amp;lt;*&amp;gt; (Just 9)
pure quadratic &amp;lt;*&amp;gt; (Just 3) &amp;lt;*&amp;gt; (Just 4) &amp;lt;*&amp;gt; (Just (-2)) &amp;lt;*&amp;gt; (Just 9)
== Just(quadratic 3 4 (-2) 9)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;さらにApplicative Functorで書いた&lt;code&gt;Maybe&lt;/code&gt;、&lt;code&gt;Applicative Maybe&lt;/code&gt;についても考えることができる
（バナナのナス、バナナスみたいだ）。
&lt;code&gt;Nothing&lt;/code&gt;が片方の項にあるなら&lt;code&gt;Nothing&lt;/code&gt;、それ以外は&lt;code&gt;Just&lt;/code&gt;を返せばいいので&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;instance Applicative Maybe where
  pure = Just
  (Just f) &amp;lt;*&amp;gt; (Just x) = Just (f x)
  _ &amp;lt;*&amp;gt; _ = Nothing
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;はい。
定義に沿った結果が返せているのでいい感じだね。&lt;/p&gt;
&lt;p&gt;具体例についてはまたどっかで追記するかもしれない。&lt;/p&gt;
&lt;h3 id=&#34;法則について&#34;&gt;
    &lt;a href=&#34;#%e6%b3%95%e5%89%87%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6&#34; class=&#34;anchor&#34;&gt;
        &lt;svg class=&#34;icon&#34; aria-hidden=&#34;true&#34; focusable=&#34;false&#34; height=&#34;16&#34; version=&#34;1.1&#34; viewBox=&#34;0 0 16 16&#34; width=&#34;16&#34;&gt;
            &lt;path fill-rule=&#34;evenodd&#34;
                d=&#34;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&#34;&gt;
            &lt;/path&gt;
        &lt;/svg&gt;
    &lt;/a&gt;
    法則について
&lt;/h3&gt;
&lt;p&gt;守らなきゃいけない法則がある。
これはHaskellというよりは、圏論からの要請っぽい。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;恒等的な関数の存在&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  pure id &amp;lt;*&amp;gt; x == x
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これはFunctor側の&lt;code&gt;fmap&lt;/code&gt;で確かめられていても、こっちで確かめなきゃいけない。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;合成則&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  pure (.) &amp;lt;*&amp;gt; u &amp;lt;*&amp;gt; v &amp;lt;*&amp;gt; w == u &amp;lt;*&amp;gt; (v &amp;lt;*&amp;gt; w)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;うーんと、何が言いたいかいまいちよくわからない感じがするけど&lt;code&gt;(u . v) w == u (v w)&lt;/code&gt;とFunctorなしの表記にするとわかりやすいのかな。
ここで&lt;code&gt;u&lt;/code&gt;と&lt;code&gt;v&lt;/code&gt;はapplicative functorの中の関数なので、先に関数を合成して計算しても、関数の結果に関数を適用しても値が同じことを保証しなければならないことを言っている。
参照透過性とかと関係あるかは不明。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;準同型&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  pure f &amp;lt;*&amp;gt; pure x == pure (f x)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;気持ち的には自明っていいたい！が証明は必要。
&lt;code&gt;pure f &amp;lt;*&amp;gt; y&lt;/code&gt;とすれば、&lt;code&gt;f y&lt;/code&gt;から&lt;code&gt;f (f x)&lt;/code&gt;より&lt;code&gt;pure (f x)&lt;/code&gt;っぽい。&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;交換則&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  f &amp;lt;*&amp;gt; pure x == pure ($ x) &amp;lt;*&amp;gt; f
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;割と意味わからん。ここはあとで追記。&lt;/p&gt;
&lt;h3 id=&#34;補足&#34;&gt;
    &lt;a href=&#34;#%e8%a3%9c%e8%b6%b3&#34; class=&#34;anchor&#34;&gt;
        &lt;svg class=&#34;icon&#34; aria-hidden=&#34;true&#34; focusable=&#34;false&#34; height=&#34;16&#34; version=&#34;1.1&#34; viewBox=&#34;0 0 16 16&#34; width=&#34;16&#34;&gt;
            &lt;path fill-rule=&#34;evenodd&#34;
                d=&#34;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&#34;&gt;
            &lt;/path&gt;
        &lt;/svg&gt;
    &lt;/a&gt;
    補足
&lt;/h3&gt;
&lt;p&gt;要はApplicative Functorは一つの国みたいなもので、&lt;code&gt;pure&lt;/code&gt;はそこに連れて行くためのコンストラクタ、&lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;はその中で関数を適用するための演算子として捉えるとわかりやすいのかな。&lt;/p&gt;
&lt;p&gt;おわり。&lt;/p&gt;

    </description>
    </item>
    
    <item>
    <title>The Road to Monads: Functorについて</title>
    <link>https://miso.sabanium.me/post/functor/</link>
    <pubDate>Sat, 04 Dec 2021 22:45:30 +0900</pubDate>
    <author>sabanium</author>
    <guid>https://miso.sabanium.me/post/functor/</guid>
    <description>
        &lt;p&gt;この記事は&lt;a href=&#34;https://oliverbalfour.github.io/haskell/2020/08/04/functors-in-haskell.html&#34;&gt;The Road to Monads&lt;/a&gt;を意訳したものです。
あんまり難しいことは言っていないと思うんだけど、あまり頭に入らなかったので簡単に翻訳してみた。&lt;/p&gt;
&lt;h2 id=&#34;functor&#34;&gt;
    &lt;a href=&#34;#functor&#34; class=&#34;anchor&#34;&gt;
        &lt;svg class=&#34;icon&#34; aria-hidden=&#34;true&#34; focusable=&#34;false&#34; height=&#34;16&#34; version=&#34;1.1&#34; viewBox=&#34;0 0 16 16&#34; width=&#34;16&#34;&gt;
            &lt;path fill-rule=&#34;evenodd&#34;
                d=&#34;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&#34;&gt;
            &lt;/path&gt;
        &lt;/svg&gt;
    &lt;/a&gt;
    Functor
&lt;/h2&gt;
&lt;h3 id=&#34;fmap&#34;&gt;
    &lt;a href=&#34;#fmap&#34; class=&#34;anchor&#34;&gt;
        &lt;svg class=&#34;icon&#34; aria-hidden=&#34;true&#34; focusable=&#34;false&#34; height=&#34;16&#34; version=&#34;1.1&#34; viewBox=&#34;0 0 16 16&#34; width=&#34;16&#34;&gt;
            &lt;path fill-rule=&#34;evenodd&#34;
                d=&#34;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&#34;&gt;
            &lt;/path&gt;
        &lt;/svg&gt;
    &lt;/a&gt;
    fmap
&lt;/h3&gt;
&lt;p&gt;Functorって何? 内部の値にアクセスできるようにしたWrapper。具体例: IO、Maybeなど。
圏論でいうところの関手。&lt;/p&gt;
&lt;p&gt;コードでの具体例：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;addMaybe :: Num a =&amp;gt; Maybe a -&amp;gt; Maybe a -&amp;gt; Maybe a
addMaybe (Just a) (Just b) = Just (a + b)
addMaybe _ _ = Nothing
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;確かに内部の値にアクセスしている。まあこれは恣意的な関数だけど。
ただし、これを一般化するといい感じになってくれる。
要は内部の値にアクセスすることが重要で、例えばf :: Int -&amp;gt; Intはこういう関数を使うことでMaybe Intにも使えるようになったりする。&lt;/p&gt;
&lt;p&gt;次に、こんな関数を考える。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;fmapList :: (a -&amp;gt; b) -&amp;gt; ([a] -&amp;gt; [b])
fmapList f [] = []
fmapList f (x:xs) = f x : fmapList f xs
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;これはmap関数と変わらない。
ある関数をリストのすべての要素に適用するだけだ。&lt;/p&gt;
&lt;p&gt;では、これを一般化するとどうなるだろう？
つまり、こんな感じの関数たちを統一的に記述できるだろうか？&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;f :: (a -&amp;gt; b) -&amp;gt; ((Just a) -&amp;gt; (Just b))
f2 :: (a -&amp;gt; b) -&amp;gt; ([a] -&amp;gt; [b])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;その関数が、functorと紐付けられたfmapである。
技術的にはfunctorはFunctor型クラスでfmapと紐付いたインスタンス。
ただし、満たすべき条件があり、それがこれ。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;fmap id == id (恒等的であること)&lt;/li&gt;
&lt;li&gt;fmap (f . g) == fmap f . fmap g (分配的であること)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;じゃあlistとMaybeの実装を見てみよう。&lt;/p&gt;
&lt;p&gt;PreludeのリストのFunctorの実装はこんな感じ。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;instance Functor [] where
  fmap = map
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上で見たとおり、fmapListはmapと同じなのだった。
mapはpythonとかの同名の関数と同じで、ある関数をリストの全要素に適用する関数。
いや、さすがにこれだとわからなくない？&lt;/p&gt;
&lt;p&gt;次にMaybeを見よう。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;instance Functor Maybe where
  fmap f (Just x) = Just (f x)
  fmap _ Nothing = Nothing
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;こっちの方が解釈はしやすい。fとJust xがあるなら、返り値（？）を(Just f x)として呼ぶことにしている。&lt;/p&gt;
&lt;p&gt;まあまあわかるような気もする。
他には、&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;data BinaryTree a = Node a (BinaryTree a) (BinaryTree a) | Leaf a
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;こんな感じのBinaryTree型を使うとき、fmapは&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;instance Functor BinaryTree where
  fmap f (Node x left right) = Node (f x) (fmap f left) (fmap f right)
  fmap f (Leaf x) = Leaf (f x)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;という感じになる。&lt;/p&gt;
&lt;p&gt;Functorというかfmapのいいところは、Wrapperの存在を意識せずに書けるところっぽい。&lt;/p&gt;

    </description>
    </item>
    
    <item>
    <title>Haskell覚え書き</title>
    <link>https://miso.sabanium.me/post/c-haskell1/</link>
    <pubDate>Sat, 04 Dec 2021 00:00:00 +0000</pubDate>
    <author>sabanium</author>
    <guid>https://miso.sabanium.me/post/c-haskell1/</guid>
    <description>
        &lt;p&gt;構文解析のためのモナド等についてまとめる。完全に自分用。&lt;/p&gt;
&lt;h3 id=&#34;haskellの文法について&#34;&gt;
    &lt;a href=&#34;#haskell%e3%81%ae%e6%96%87%e6%b3%95%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6&#34; class=&#34;anchor&#34;&gt;
        &lt;svg class=&#34;icon&#34; aria-hidden=&#34;true&#34; focusable=&#34;false&#34; height=&#34;16&#34; version=&#34;1.1&#34; viewBox=&#34;0 0 16 16&#34; width=&#34;16&#34;&gt;
            &lt;path fill-rule=&#34;evenodd&#34;
                d=&#34;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&#34;&gt;
            &lt;/path&gt;
        &lt;/svg&gt;
    &lt;/a&gt;
    Haskellの文法について
&lt;/h3&gt;
&lt;p&gt;よく見るやつ&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;型拘束&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;(Ord a) =&amp;gt; a -&amp;gt; a
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;要素の存在&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;(x:xs)
&lt;/code&gt;&lt;/pre&gt;
    </description>
    </item>
    
    <item>
    <title>HaskellでCコンパイラもどきを作る #0</title>
    <link>https://miso.sabanium.me/post/c-haskell0/</link>
    <pubDate>Fri, 03 Dec 2021 00:00:00 +0000</pubDate>
    <author>sabanium</author>
    <guid>https://miso.sabanium.me/post/c-haskell0/</guid>
    <description>
        &lt;p&gt;まず環境構築をする。&lt;/p&gt;
&lt;h3 id=&#34;haskellのインストール&#34;&gt;
    &lt;a href=&#34;#haskell%e3%81%ae%e3%82%a4%e3%83%b3%e3%82%b9%e3%83%88%e3%83%bc%e3%83%ab&#34; class=&#34;anchor&#34;&gt;
        &lt;svg class=&#34;icon&#34; aria-hidden=&#34;true&#34; focusable=&#34;false&#34; height=&#34;16&#34; version=&#34;1.1&#34; viewBox=&#34;0 0 16 16&#34; width=&#34;16&#34;&gt;
            &lt;path fill-rule=&#34;evenodd&#34;
                d=&#34;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&#34;&gt;
            &lt;/path&gt;
        &lt;/svg&gt;
    &lt;/a&gt;
    Haskellのインストール
&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.haskell.org/downloads/&#34;&gt;これ&lt;/a&gt;を読んで、GHCupとHaskell Tool Stackの一番上の方にのってるcurlコマンドを叩く。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;curl --proto &#39;=https&#39; --tlsv1.2 -sSf https://get-ghcup.haskell.org | sh
curl -sSL https://get.haskellstack.org/ | sh
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;LSPは必要なので入れて、それ以外のものにも大体Yesと回答した気がする。なんかPとか押させるのが厄介。&lt;/p&gt;
&lt;h3 id=&#34;haskell-language-serverの導入&#34;&gt;
    &lt;a href=&#34;#haskell-language-server%e3%81%ae%e5%b0%8e%e5%85%a5&#34; class=&#34;anchor&#34;&gt;
        &lt;svg class=&#34;icon&#34; aria-hidden=&#34;true&#34; focusable=&#34;false&#34; height=&#34;16&#34; version=&#34;1.1&#34; viewBox=&#34;0 0 16 16&#34; width=&#34;16&#34;&gt;
            &lt;path fill-rule=&#34;evenodd&#34;
                d=&#34;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&#34;&gt;
            &lt;/path&gt;
        &lt;/svg&gt;
    &lt;/a&gt;
    Haskell Language Serverの導入
&lt;/h3&gt;
&lt;p&gt;vim-lsp-settingsはHaskell Language Server(以下HLS)に対応していないがvim-lsp-settingsの&lt;a href=&#34;https://github.com/mattn/vim-lsp-settings/issues/309&#34;&gt;issue&lt;/a&gt;を読むとそういうことが書いてあるので.vimrcを適当にいじるとうまくHLSが動く。&lt;/p&gt;
&lt;p&gt;これでGHC+HLSが入った環境が準備できた。&lt;/p&gt;

    </description>
    </item>
    
  </channel>
</rss>
